---
description: Prospective memory fails 30-50% of the time in humans and degrades with context load in agents, but event-triggered hooks structurally eliminate the failure mode rather than trying to make
kind: research
topics: ["[[agent-cognition]]"]
methodology: ["Cognitive Science", "Original"]
source: [[hooks-as-methodology-encoders-research-source]]
---

# auto-commit hooks eliminate prospective memory failures by converting remember-to-act into guaranteed execution

Prospective memory is the cognitive function responsible for remembering to do something in the future. Not remembering facts (retrospective memory) but remembering intentions: take medication at 8 PM, buy milk on the way home, commit code before switching branches. It is one of the least reliable cognitive functions humans possess, with laboratory studies showing failure rates of 30-50% even under controlled conditions. The failures are not random -- they cluster around moments of high cognitive load, when the person is deeply engaged in substantive work and has the least bandwidth for procedural remembering.

Agents face an analogous problem, though the mechanism differs. An agent has no biological prospective memory system, but instructions in the context window serve the same function: "remember to commit after editing," "remember to update the index after creating a note," "remember to check for broken links before ending the session." Since [[LLM attention degrades as context fills]], these instruction-based prospective memory demands degrade precisely when they matter most. An agent deep in connection finding or synthesis work has filled its context with source material, existing notes, and intermediate reasoning. The instruction to "commit after this edit" competes with all of that for attention. The failure mode is the same as in humans: the more cognitively demanding the primary task, the more likely the prospective memory task is forgotten.

The cost of maintaining these unfulfilled intentions is not zero. Since [[Zeigarnik effect validates capture-first philosophy because open loops drain attention]], each pending intention functions as an open loop that drains working memory continuously until resolved. A prospective memory task like "commit after this edit" is exactly such an open loop -- it persists in the background, consuming bandwidth, until the agent either executes the commit or forgets the intention entirely. The Zeigarnik research documents this mechanism for task-level open loops; prospective memory demands are a specific category of open loops where the intention to act in the future generates ongoing cognitive cost in the present.

The standard approach to prospective memory failure -- in both humans and agents -- is to try to make remembering more reliable. Humans set alarms, write sticky notes, create checklists. Agent instructions get bolded, repeated, placed at the top of the prompt. These are all attempts to strengthen the prospective memory cue. But they are fighting against the fundamental architecture of attention-limited systems: strengthening one cue weakens relative salience of other cues, and under genuine cognitive load, even strong cues get missed.

Auto-commit hooks take a structurally different approach. Rather than making the agent better at remembering to commit, they eliminate the need to remember entirely. The file write event triggers the commit action. No prospective memory demand exists because there is no future intention to maintain. The agent writes a file and continues reasoning. The commit happens because the event occurred, not because anyone remembered.

This parallels the cognitive science distinction between time-based and event-based prospective memory. Time-based prospective memory ("remember at 8 PM") is unreliable because it requires periodic self-initiated retrieval -- you must keep checking whether it is 8 PM yet, and each check consumes attention. Event-based prospective memory ("remember when I see the pharmacy") is more reliable because the environmental cue triggers retrieval automatically. Auto-commit hooks are the infrastructure equivalent of event-based prospective memory: the file write IS the environmental cue, and the hook IS the triggered action. But hooks go further than event-based prospective memory because even event-based prospective memory can fail when attention is consumed elsewhere. A person deeply absorbed in conversation may walk past the pharmacy without noticing it. A hook fires regardless of what the agent is attending to, because the trigger is in the infrastructure, not in the attention system.

The async execution model adds a further optimization. Because auto-commit runs asynchronously, the commit does not block the agent's workflow. The agent writes, continues reasoning, and the commit completes in the background. This eliminates not just the prospective memory demand but also the task-switching cost that would accompany a synchronous commit. Without async execution, eliminating prospective memory would still introduce an interruption -- the agent pauses to commit, loses its place, and must re-orient to the substantive work. Async execution eliminates both the memory demand and the switching cost. Since [[hooks enable context window efficiency by delegating deterministic checks to external processes]], this is a double benefit: the prospective memory demand disappears (this note's primary argument) and the context window tokens that would have been spent on commit reasoning are preserved for substantive work (the efficiency argument). The two benefits reinforce each other because the tokens saved remain available for cognitive work during exactly the period when attention degradation would have made the prospective memory task most likely to fail.

This safety depends on a property that auto-commit inherits from git's design: since [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]], committing when nothing has changed is a no-op. The hook fires on every write event, and write events can cluster or repeat through rapid saves, crash recovery, or concurrent operations. If auto-commit were not idempotent -- if each firing produced an additional commit regardless of whether the working tree had changed -- the result would be a polluted git history from redundant commits. Git's own idempotency makes the hook safe to fire at any frequency, which is why auto-commit is a canonical example of an idempotent hooked operation.

The broader principle extends beyond commits. Any operation that fits the pattern "after X, always do Y" is a prospective memory demand that a hook can eliminate. Index synchronization after note creation, broken link checking after edits, queue updates after task completion -- each of these is a "remember to" instruction that competes for attention and fails under load. Since [[session boundary hooks implement cognitive bookends for orientation and reflection]], even the bookend pattern is an instance: "remember to orient at session start" and "remember to reflect before stopping" are prospective memory demands that SessionStart and Stop hooks eliminate through event triggers. The bookend hooks do not require the agent to remember that orientation and reflection matter -- they fire because the session boundary event occurred. Since [[the determinism boundary separates hook methodology from skill methodology]], the key is that these operations must be deterministic: the same trigger should always produce the same action, regardless of what the agent is working on. When the action requires judgment (like evaluating whether a description is good enough), it belongs in a skill. When it requires only execution (like committing a file change), it belongs in a hook, because since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], hooks fire on every event while instructions degrade with context load.

The relationship to the broader offloading architecture is precise. Since [[cognitive offloading is the architectural foundation for vault design]], the vault externalizes working memory to files and executive function to hooks. Prospective memory offloading is a specific, well-characterized instance of this pattern. Working memory offloading says "don't hold facts in mind, write them down." Prospective memory offloading says "don't hold intentions in mind, encode them as event triggers." Since [[hooks are the agent habit system that replaces the missing basal ganglia]], habits and prospective memory are distinct cognitive functions that hooks address through the same mechanism -- event-driven automation -- but for different reasons. Habits are about automatizing repeated behaviors so they stop consuming executive function. Prospective memory is about ensuring future actions actually happen despite attention being consumed elsewhere. The hook mechanism solves both, but the cognitive problems are different, and conflating them obscures the specific value proposition of each.

The claim is closed. The cognitive science on prospective memory failure rates is established, the mechanism by which hooks eliminate the failure mode is straightforward (event triggers replace intention maintenance), and the vault's auto-commit implementation demonstrates the pattern concretely.

---
---

Relevant Notes:
- [[hooks are the agent habit system that replaces the missing basal ganglia]] -- covers habit formation (basal ganglia) as the general cognitive gap hooks fill; this note identifies a specific cognitive function -- prospective memory -- that auto-commit hooks eliminate entirely rather than merely compensating for
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] -- the enforcement mechanism: prospective memory demands live in the instruction layer where they compete for attention, while hooks live in infrastructure where they fire regardless of cognitive state
- [[cognitive offloading is the architectural foundation for vault design]] -- offloading prospective memory is a specific instance of the broader offloading architecture; working memory offloads to files, habit offloads to hooks, and prospective memory offloads to event triggers
- [[the determinism boundary separates hook methodology from skill methodology]] -- auto-commit sits at the fully deterministic end of the spectrum, producing identical results regardless of input content or agent reasoning quality, which is exactly why it should be a hook rather than an instruction
- [[Zeigarnik effect validates capture-first philosophy because open loops drain attention]] -- prospective memory tasks are open loops in the Zeigarnik sense: each remember-to-commit intention drains working memory continuously until executed or externalized; auto-commit hooks close these loops structurally rather than through execution discipline
- [[session boundary hooks implement cognitive bookends for orientation and reflection]] -- session-start eliminates remember-to-orient and Stop eliminates remember-to-reflect, making bookend hooks two more instances of the prospective memory elimination pattern this note identifies
- [[hooks enable context window efficiency by delegating deterministic checks to external processes]] -- complementary benefit: auto-commit eliminates both prospective memory demand (this note) and context token cost (that note) simultaneously through the same mechanism
- [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]] -- explains WHY auto-commit is safe for repeated firing: git's design ensures committing unchanged files is a no-op, making auto-commit a canonical example of an idempotent hooked operation

Topics:
- [[agent-cognition]]
