---
description: Validation hooks that warn on schema violations without blocking preserve flexibility while encouraging consistency — quality gates as guidance rather than gatekeeping
kind: research
topics: ["[[processing-workflows]]"]
methodology: ["Original"]
source: [[2-4-metadata-properties]]
---

# schema enforcement via validation agents enables soft consistency

Hard schema enforcement creates a binary: comply or fail. Tana's supertags demonstrate the power of automatic schema enforcement — tag a node as `#book` and it inherits fields for Author, Publication Year, ISBN. The schema applies without asking. But this rigidity has costs: when content doesn't fit the schema, you either force it into ill-fitting boxes or abandon the type system entirely.

Soft enforcement offers a middle path. A validation agent checks notes against schema requirements but generates warnings rather than errors. Required fields missing? Flag it. Description over character limit? Flag it. Title doesn't follow conventions? Flag it. The note still saves. The system still functions. But the violation is visible, creating pressure toward compliance without creating blocks.

This maps to how linters work in code: they warn about style violations without preventing compilation. The code runs, but the warnings accumulate until someone addresses them. Soft consistency means the system trends toward schema compliance over time without requiring perfection at every moment. Since [[complex systems evolve from simple working systems]], starting with soft enforcement allows the system to mature — hard enforcement can be added at specific points where warnings prove insufficient, but starting hard risks the rejection cascade. This is especially valuable during high-velocity capture when friction costs matter most — since [[temporal separation of capture and processing preserves context freshness]], forcing full schema compliance at capture time trades context preservation for format purity.

The agent implementation pattern looks like this:

| Check | Trigger | Output |
|-------|---------|--------|
| Required fields for type | Note create/modify | Warning if missing |
| Description under limit | Note create/modify | Warning if exceeded |
| Title follows conventions | Note create/modify | Warning if violation |
| Link targets exist | Any wiki link | Warning if dangling |

The warnings aggregate somewhere visible — a health dashboard, a log file, an inbox for schema violations. Processing happens in batches during maintenance, not at the moment of creation. This is the opposite of Tana's synchronous enforcement: asynchronous validation that shapes behavior through visibility rather than blocking.

There's a deeper principle here about consistency in agent-operated systems. Since [[schema templates reduce cognitive overhead at capture time]], the schema exists to reduce decisions, not to gatekeep. Validation agents extend this: they ensure the schema's benefits (queryability, precision) without the schema's costs (friction, rigidity). The validation agent is a maintenance pass that surfaces drift from intended structure without preventing work.

The soft/hard distinction maps to different failure modes. Hard enforcement risks: abandonment (too much friction), workarounds (fake values to satisfy validators), scope creep (expanding schemas to handle edge cases). Soft enforcement risks: permanent drift (warnings ignored indefinitely), inconsistency (some notes validated, others not), false sense of compliance (warnings exist but content quality degrades). This contrasts with [[generation effect gate blocks processing without transformation]], which implements hard enforcement for inbox exit — but the gate targets a different problem (ensuring processing happens at all) while validation agents target consistency of already-processed content. The bet with soft enforcement is that visibility creates sufficient pressure — that agents and humans will address accumulated warnings during maintenance passes rather than requiring enforcement at creation time.

This connects to the vault's existing hook infrastructure, but the connection is tier-dependent. Schema validation is a concrete feature that straddles the sharpest gap in the layer hierarchy: since [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]], schema definitions live in the convention layer (instruction-encoded templates that any context-file platform can carry), while hook-based enforcement lives in the automation layer (infrastructure that fires regardless of agent attention). Since [[platform capability tiers determine which knowledge system features can be implemented]], hook-based validation is a tier-one feature: a PostToolUse hook on note creation can validate schema compliance and append to a warnings log. The hook doesn't block the Write tool; it runs after and records violations. Periodic review of the warnings log becomes part of the maintenance cycle alongside link checking and orphan detection. The validation agent is really just a specialized reviewer — a maintenance agent that checks structure rather than connections. Since [[testing effect could enable agent knowledge verification]] demonstrates how prediction-then-verify cycles reveal description quality, validation agents apply the same pattern to schema compliance: check, flag, accumulate, address during maintenance. The [[retrieval verification loop tests description quality at scale]] extends this to systematic scoring — validation agents could similarly score schema compliance across the vault to identify pattern failures (which note types have worst compliance? which schema fields are most often missing?).

The implementation principle: validate asynchronously, surface visibly, fix during maintenance. Schema enforcement becomes a background process that shapes quality over time rather than a gate that blocks creation in the moment. This consistency role is architecturally critical because since [[markdown plus YAML plus ripgrep implements a queryable graph database without infrastructure]], soft validation is the data integrity layer of a four-layer graph database -- the layer that keeps the other three (edges, metadata, faceted access) queryable over time. Without consistency enforcement, metadata fields drift, query patterns break, and the structured access degrades into the unstructured search it replaced. The graph database framing makes the stakes of validation concrete: schema drift is not a cosmetic issue but a database corruption problem. Since [[nudge theory explains graduated hook enforcement as choice architecture for agents]], this soft enforcement design is the choice architecture principle made concrete: the validation agent is a nudge, not a mandate, and nudges work precisely because they shape behavior without removing agency. The graduation this note describes between hard enforcement (block on missing required fields) and soft enforcement (warn on quality issues) maps directly to the mandate-vs-nudge spectrum, with the additional volume dimension that threshold-based pattern alerting prevents even well-calibrated warnings from accumulating into noise. And since [[schema evolution follows observe-then-formalize not design-then-enforce]], the accumulated warnings are not just maintenance items — they are the evidence base for schema evolution decisions. When quarterly review finds that 20% of notes manually add a field, that signal came from the drift that soft enforcement recorded rather than blocked. Soft enforcement and observe-then-formalize are two phases of the same feedback loop: enforcement generates observation data, evolution converts that data into schema decisions. And since [[intermediate representation pattern enables reliable vault operations beyond regex]], the validation infrastructure itself could improve — instead of re-parsing YAML from raw text on every check, validators would operate on pre-parsed typed dictionaries where required-field detection and enum validation become property lookups rather than regex extraction that breaks on multiline values or edge-case formatting.

Soft enforcement becomes especially critical in multi-domain systems. Since [[multi-domain systems compose through separate templates and shared graph]], when domains with different schemas coexist in one graph, hard enforcement that blocks on a therapy field violation would stall research processing — cross-domain interference where one domain's schema strictness affects another's workflow. Soft validation lets each domain maintain its own schema standards independently, warning about violations without creating cross-domain blocking dependencies. This is not a relaxation of quality but a recognition that enforcement scope must match domain boundaries to avoid the interference that composition introduces. The same scoping principle applies within a single domain: since [[progressive schema validates only what active modules require not the full system schema]], the validator checks only fields belonging to active modules, so a user with just yaml-schema and wiki-links enabled never encounters warnings about topics or methodology fields from modules they have not adopted — soft enforcement scoped by both domain boundaries and module activation state.
---

Relevant Notes:
- [[markdown plus YAML plus ripgrep implements a queryable graph database without infrastructure]] — synthesis: validation is the data integrity layer of the four-layer graph database; without soft consistency, metadata drift corrupts the query layer that makes the database functional
- [[schema templates reduce cognitive overhead at capture time]] — the capture-side complement: templates reduce decisions at creation, validation agents catch drift afterward
- [[nudge theory explains graduated hook enforcement as choice architecture for agents]] — provides the choice architecture theory that grounds soft enforcement: validation warnings are nudges, required field blocks are mandates, and the graduation between them follows Thaler and Sunstein's insight that intervention strength should match violation severity
- [[metadata reduces entropy enabling precision over recall]] — schema validation ensures the metadata that enables precision actually gets created and stays consistent
- [[temporal separation of capture and processing preserves context freshness]] — justifies soft over hard: dont sacrifice context preservation for format compliance at capture time
- [[skills encode methodology so manual execution bypasses quality gates]] — validation agents are another form of encoded methodology: automated quality checks that run regardless of invocation path
- [[testing effect could enable agent knowledge verification]] — sibling verification pattern: prediction-then-verify for descriptions, check-then-flag for schema compliance; both use async verification that accumulates for maintenance
- [[retrieval verification loop tests description quality at scale]] — operationalizes systematic quality checking: the same scoring and pattern detection approach applies to schema compliance
- [[generation effect gate blocks processing without transformation]] — the hard enforcement pole: generation gate blocks inbox exit, while validation agents warn without blocking; both are quality gates at different points with different strictness
- [[complex systems evolve from simple working systems]] — Gall's Law applied to schema systems: start with soft enforcement (simple), add hard enforcement only where pain demonstrates need
- [[programmable notes could enable property-triggered workflows]] — extends the trigger model: validation hooks fire on file events (Write), programmable notes fire on property conditions (semantic state); both are quality automation but at different abstraction levels
- [[intermediate representation pattern enables reliable vault operations beyond regex]] — infrastructure upgrade: validation currently re-parses YAML from raw text each check; an IR layer means validators operate on pre-parsed typed dictionaries, making required-field checks property lookups rather than regex extraction
- [[platform capability tiers determine which knowledge system features can be implemented]] — hook-based validation is a tier-one feature; at tier two and three, schema enforcement degrades from guaranteed hook-fired checks to instruction-based compliance that drifts as context fills
- [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]] — schema validation straddles the convention-automation boundary: schema definitions live in convention (instruction-encoded templates), while hook-based enforcement lives in automation; this feature concretely demonstrates the sharpest gap in the layer hierarchy
- [[schema evolution follows observe-then-formalize not design-then-enforce]] — temporal partner: soft enforcement generates the observation data that the evolution protocol consumes; validation warnings accumulate as the evidence base for quarterly schema review decisions, making enforcement and evolution two phases of the same feedback loop
- [[multi-domain systems compose through separate templates and shared graph]] — cross-domain enforcement scope: soft validation prevents cross-domain interference where one domain's schema strictness stalls another's processing, making domain-scoped warnings essential for multi-domain composition
- [[progressive schema validates only what active modules require not the full system schema]] — extends enforcement scope from domain boundaries to module activation: the validator checks only fields from active modules, adding a second flexibility axis alongside soft-vs-hard enforcement
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — soft enforcement is the validation-layer implementation of the guarantee: warn-without-blocking ensures that valid module configurations never encounter spurious enforcement failures that would violate the composability promise

Topics:
- [[processing-workflows]]
