---
description: Minimum viable seeding, friction-driven evolution, principled restructuring when incoherence accumulates — reseeding re-derives from first principles enriched by operational experience
kind: research
topics: ["[[design-dimensions]]", "[[maintenance-patterns]]"]
methodology: ["Systems Theory", "Original"]
source: [[knowledge-system-derivation-blueprint]]
---

# derived systems follow a seed-evolve-reseed lifecycle

Knowledge systems derived from research claims do not follow a simple create-then-maintain trajectory. They move through three qualitatively different phases, and understanding which phase you are in determines what actions are appropriate.

**Seeding** is initial derivation constrained by Gall's Law. Since [[complex systems evolve from simple working systems]], the derived system must start as a minimum viable configuration: two or three note types, a handful of MOCs, basic folder structure, and a context file that teaches the agent how to operate and — crucially — how to evolve. Because [[methodology traditions are named points in a shared configuration space not competing paradigms]], the seed can start from a tradition's pre-validated configuration rather than composing from raw dimensions, and because [[novel domains derive by mapping knowledge type to closest reference domain then adapting]], unfamiliar domains can use reference domains as seeding points with adaptation axes defining the initial evolution trajectory. The temptation is to derive the theoretically optimal configuration from the claim graph. But even a perfectly justified complex system will collapse under its own weight because the countless micro-adaptations that make a system work can only emerge through use. What makes this incremental adoption safe is that [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — enabling a module cannot break existing structure, so the seed phase can start minimal with confidence that each subsequent addition is non-destructive. The most accessible seeding mechanism is the use-case preset. Since [[use-case presets dissolve the tension between composability and simplicity]], presets bundle a curated module selection under a use-case label — the user selects "Research Vault" and gets thirteen modules covering the full pipeline, without composing the selection from scratch. The preset resolves dimension coupling and dependency chains at activation time, producing a minimum viable configuration that the user can evolve through friction-driven module toggling. The seed includes evolution guidelines: when to add a field, when to create a new MOC, when to adjust processing cadence. These guidelines are as important as the initial structure because they encode the conditions under which complexity is justified.

**Evolution** is growth through observed friction. Since [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]], the evolution phase has concrete thresholds: add a module after five manual repetitions of the process it would automate, split a module when its description exceeds 500 characters, remove after three unused sessions, and cap active modules at fifteen to twenty. Because [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], each capability is an independent module with explicit dependencies, so evolution means toggling modules on at these calibrated friction points rather than restructuring a monolithic configuration — the agent adds yaml-schema when structured metadata becomes necessary, processing-pipeline when manual workflows create friction, each addition resolving its own dependencies and composing with everything already active. The agent monitors which note types get used, which fields actually get filled, where navigation fails, where processing produces unlinked notes. Each adaptation traces back to a specific observation mapped to a knowledge graph claim — not intuition but evidence. Since [[schema evolution follows observe-then-formalize not design-then-enforce]], the concrete protocol for schema evolution is a quarterly review with five signals: add a field when 20% of notes manually include it, demote required fields that collect placeholder values, prune unused enums, formalize patterned free text, split MOCs that exceed navigation thresholds. Since [[bootstrapping principle enables self-improving systems]], this phase is bootstrapping in action: the system uses its current capabilities to identify and implement improvements, with each improvement becoming available for the next cycle. And since [[incremental formalization happens through repeated touching of old notes]], the notes themselves are evolving in parallel with the system — claims sharpen, connections densify, vague inklings crystallize — so the system and its content co-evolve. The encoding trajectory mirrors this: since [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]], methodology patterns within the system follow their own seed-evolve cycle — seeded as documentation in the context file, evolved through friction encounters into skills, and hardened into hooks when understanding is sufficient.

But evolution has a limit, and without the transition to reseeding, [[PKM failure follows a predictable cycle]] — over-engineering and analysis paralysis set in as people attempt to fix systemic incoherence with local adaptations. Small adaptations accumulate side effects. A field added here creates a query expectation there. A new MOC shifts navigation patterns that other MOCs assumed were stable. Because [[configuration dimensions interact so choices in one create pressure on others]], changes in one dimension create pressure on others, and accumulated incremental changes can drift the configuration into an incoherent region where individual choices are locally justified but globally contradictory. Schema drift, navigation degradation, processing pipelines that no longer match the content they handle — these are symptoms of a system that has evolved past its derived coherence without restructuring. And since [[module deactivation must account for structural artifacts that survive the toggle]], experimentation itself becomes a source of incoherence: each module that was enabled, tested, and then disabled leaves ghost YAML fields and orphaned MOC links that accumulate as structural debris proportional to the number of experiments attempted.

**Reseeding** is the response: principled restructuring that re-derives the system using original constraints enriched by accumulated observations. This is fundamentally different from both incremental evolution and routine maintenance. Since [[backward maintenance asks what would be different if written today]], reweaving asks this question at the note level — what would this note say given current understanding? Reseeding asks it at the system level — what would this entire architecture look like given what we now know about how it gets used? The scale difference matters because systemic incoherence cannot be fixed by improving individual notes. You need to step back and reconsider the templates, the pipeline structure, the MOC hierarchy, the processing cadence — the framework that everything else depends on. And since [[every knowledge domain shares a four-phase processing skeleton that diverges only in the process step]], reseeding does not redesign the skeleton itself — capture, process, connect, verify remain invariant — but restructures the process step implementation, the schema definitions, and the navigation hierarchy that sit on top of it.

What makes reseeding principled rather than ad hoc is that [[derivation generates knowledge systems from composable research claims not template customization]]. The same claim graph that produced the initial seed now has additional inputs: every observation logged during evolution, every tension discovered through use, every adaptation and its justification. Re-derivation traverses the enriched claim graph with tighter constraints: not "what does the research suggest for this use case?" but "what does the research suggest for this use case given these specific operational realities?" The output preserves all content, all links, all accumulated understanding — it restructures the framework around them.

The lifecycle is not linear but spiral. After reseeding, a new evolution phase begins from the restructured base, accumulating new observations until the next reseeding is warranted. Each cycle produces a system that is both more adapted to its actual use patterns and more coherent in its configuration choices. The claim graph itself improves through this process: observations from deployed systems feed back as new claims or sharpened existing ones, making subsequent derivations — for this system or any other — more grounded.

There is a tension in recognizing when evolution should give way to reseeding. Too early, and you discard adaptations that haven't had time to prove their value. Too late, and incoherence compounds until the system's behavior becomes unpredictable. The trigger signals are systemic rather than local: not "this field doesn't work" (that is an evolution-phase adaptation) but "our schema, navigation, and processing have drifted apart" (that requires reseeding). Since [[gardening cycle implements tend prune fertilize operations]], the gardening metaphor clarifies the distinction: tending and fertilizing are evolution-phase operations that maintain and connect existing plants. Reseeding redesigns the garden's layout — which beds exist, how paths connect them, what the irrigation system looks like — while preserving the plants themselves.

The practical implication is that derived systems need to be designed for reseeding from the start. Since [[context files function as agent operating systems through self-referential self-extension]], the context file is the natural home for reseeding meta-documentation — not just how to operate but how to re-derive: what constraints were used, what trade-offs were made and why, what observations would trigger reconsideration. A system that lacks this meta-documentation can still be reseeded, but the re-derivation loses access to the reasoning behind the original choices, making it more likely to repeat mistakes the first derivation already resolved.
---

Relevant Notes:
- [[complex systems evolve from simple working systems]] — provides the theoretical foundation: Gall's Law explains why seeding must start simple, but this note adds the reseeding phase that Gall's Law alone does not describe
- [[bootstrapping principle enables self-improving systems]] — evolution is bootstrapping in action, but reseeding is a phase transition that bootstrapping alone cannot accomplish because the system must step outside itself to re-derive
- [[backward maintenance asks what would be different if written today]] — reweaving operates at the note level while reseeding operates at the system level: both ask what current understanding would change, but at different scales
- [[derivation generates knowledge systems from composable research claims not template customization]] — derivation is the mechanism that makes reseeding principled rather than ad hoc: the claim graph provides the substrate for re-derivation
- [[incremental formalization happens through repeated touching of old notes]] — evolution phase works through incremental formalization at the note level, but reseeding recognizes that accumulated incremental changes can produce systemic incoherence that incremental approaches cannot fix
- [[configuration dimensions interact so choices in one create pressure on others]] — dimension coupling explains why evolution eventually requires reseeding: small adaptations in one dimension accumulate pressure on others until the configuration drifts into an incoherent region
- [[gardening cycle implements tend prune fertilize operations]] — tend and fertilize are evolution-phase operations while reseeding is a qualitatively different act: restructuring the garden's layout rather than maintaining its plants
- [[evolution observations provide actionable signals for system adaptation]] — provides the specific diagnostic protocol for the evolution phase: six observation patterns map to structural causes, telling the agent whether accumulated drift is still incremental (evolution-phase correction) or has crossed into systemic incoherence (reseeding trigger)
- [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]] — the encoding trajectory is a lifecycle within the evolution phase: methodology patterns seed as documentation, evolve through friction, and reseed at the next encoding level when understanding hardens
- [[schema evolution follows observe-then-formalize not design-then-enforce]] — the schema-specific instantiation of the evolution phase: the quarterly review protocol with five concrete signals is how schemas evolve through observation rather than upfront design
- [[PKM failure follows a predictable cycle]] — the failure cascade is what happens when the evolution phase stalls and reseeding never occurs: over-engineering and analysis paralysis are symptoms of attempting local fixes for systemic incoherence
- [[every knowledge domain shares a four-phase processing skeleton that diverges only in the process step]] — clarifies what reseeding actually restructures: the skeleton itself (capture-process-connect-verify) is invariant, so reseeding targets the process step implementation, templates, and MOC hierarchy rather than the pipeline shape
- [[methodology traditions are named points in a shared configuration space not competing paradigms]] — traditions serve as pre-validated seeding points: a derived system can seed from a tradition's coherent configuration rather than composing from raw dimensions
- [[novel domains derive by mapping knowledge type to closest reference domain then adapting]] — extends the seeding concept: reference domains function as seeds for novel domains, with adaptation axes defining the initial evolution trajectory
- [[context files function as agent operating systems through self-referential self-extension]] — the context file is the substrate where reseeding meta-documentation lives: self-referential self-extension enables the context file to teach not just operation but re-derivation
- [[premature complexity is the most common derivation failure mode]] — the complexity budget is the seeding constraint: minimum viable configuration at seed time with evolution guidelines encoding when to add complexity rather than front-loading it; the budget constrains initial deployment between the kernel floor and the locally-justified-but-globally-unsustainable maximum
- [[configuration paralysis emerges when derivation surfaces too many decisions]] — configuration paralysis can prevent the seeding phase from completing: if the derivation interface surfaces every dimension as a question, the user never finishes setup, so the system never reaches the evolution phase where friction-driven learning begins
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the safety property that makes the seed-evolve cycle reliable: each module toggle during seed and evolution phases is non-destructive because the guarantee ensures valid combinations never corrupt data or break structure
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — the implementation pattern that makes the lifecycle's module-level toggling possible: seeding activates a minimal module set, evolution toggles modules on at friction points, and reseeding reconfigures the module selection; composable architecture is the engineering substrate on which the lifecycle operates
- [[use-case presets dissolve the tension between composability and simplicity]] — the most accessible seeding mechanism: presets bundle curated module selections under use-case labels so seeding requires one choice rather than individual module evaluation, with the composable substrate enabling friction-driven evolution after the preset provides initial configuration
- [[module deactivation must account for structural artifacts that survive the toggle]] — deactivation debris as a reseeding trigger: experimentation during the evolution phase leaves ghost YAML fields and orphaned MOC links from disabled modules, accumulating structural debris that comprehensive cleanup during reseeding addresses as part of principled restructuring
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — the evolution phase's specific mechanism: concrete thresholds (5-repetition addition, 500-char split, 3-session removal, 15-20 module cap) operationalize friction-driven toggling, preventing both premature adoption and configuration debt during the evolution phase

Topics:
- [[design-dimensions]]
- [[maintenance-patterns]]
