---
description: Without retirement criteria the automation layer grows monotonically — checks added when problems appear but never removed when problems vanish, accumulating noise that degrades the signal quality of
kind: research
topics: ["[[maintenance-patterns]]", "[[agent-cognition]]"]
methodology: ["Systems Theory", "Original"]
source: [[automated-knowledge-maintenance-blueprint]]
---

# automation should be retired when its false positive rate exceeds its true positive rate or it catches zero issues

Most discussion about automation focuses on what to build. The questions are familiar: is this operation deterministic enough? Is it idempotent? Does it cross the judgment boundary? Since [[the determinism boundary separates hook methodology from skill methodology]], the vault has a principled framework for deciding what to automate. But there is no corresponding framework for the complementary question: when should automation be removed? Since [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]], the vault has a principled model for how automation is created — patterns mature from documentation through skills into hooks as understanding hardens. Retirement is the missing lifecycle complement: the trajectory that moves automation from nothing to hook needs a corresponding trajectory that moves it from hook back to nothing when the problem it guards against ceases to exist.

This asymmetry matters because automation accumulates. Every hook that works well justifies its existence, and since [[hooks cannot replace genuine cognitive engagement yet more automation is always tempting]], the gravitational pull is always toward more checks, more enforcement, more automated monitoring. Without explicit retirement criteria, the automation layer grows monotonically — checks are added when problems are discovered but never removed when problems disappear. The result is an automation layer that produces increasing noise relative to signal, because some fraction of its checks are validating conditions that no longer fail.

Four signals indicate that an automated check should be retired.

**Zero catches over an extended period.** If a check has caught nothing for three or more months of active use, the condition it guards against has likely been structurally eliminated. A schema validation hook that once caught missing description fields might now fire on every write and pass every time, because the create skill already guarantees the field. The hook is not wrong — it still correctly validates — but it is redundant, consuming attention budget without producing value. The structural elimination might come from upstream fixes, methodology changes, or skill improvements that make the downstream check unnecessary. The diagnostic parallel is direct: since [[evolution observations provide actionable signals for system adaptation]], the observation protocol already identifies unused note types as signals of over-modeling. A zero-catch automation check is the infrastructure analog — an over-modeled protection against a problem that no longer exists.

**False positive rate exceeding true positive rate.** When a check produces more false alerts than genuine catches, it is consuming more time to handle spurious warnings than it saves by catching real problems. This is the alert fatigue threshold — the point at which the check actively degrades system attention rather than protecting system quality. Since [[confidence thresholds gate automated action between the mechanical and judgment zones]], the vault already tracks confidence as a gating mechanism for automated action. Retirement extends this: confidence thresholds determine whether to act on a single result, while retirement asks whether the check as a whole still produces enough true positives to justify its false positive cost. The distinction matters because a perfectly calibrated threshold on a check that catches nothing useful is still wasted infrastructure. Empirical tracking of the ratio is essential — without it, the check persists on the assumption that it is working, which is exactly the self-concealing error pattern that since [[over-automation corrupts quality when hooks encode judgment rather than verification]] warns about for individual hooks scaled to the lifecycle level.

**Methodology change making the check irrelevant.** When the system's methodology evolves, checks designed for the previous methodology may no longer apply. A check that enforced a three-tier MOC hierarchy becomes irrelevant if the vault adopts a flat structure. A validation hook for a deprecated YAML field catches violations of a constraint that no longer exists. This signal is harder to detect automatically because it requires understanding the relationship between the check and the methodology it enforces — but since [[hook-driven learning loops create self-improving methodology through observation accumulation]], the learning loop that drives methodology evolution should also drive retirement of checks that the evolution rendered obsolete. The observation "hook X fires but the condition it validates no longer appears in CLAUDE.md" is itself a retirement signal.

**Replacement by a better mechanism.** A hook that validates description length might be superseded by a skill that evaluates description quality semantically. The old check is not wrong, but it is dominated — the new mechanism catches everything the old one catches plus more, making the old one redundant rather than complementary. The retirement criterion here is strict subsumption: the replacement must catch all true positives the original catches, not just some of them. Partial replacement should trigger evaluation of whether the unreplaced portion is still valuable, not automatic retirement.

The deeper principle is that automation has a lifecycle, and that lifecycle includes an end. Since [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]], the vault already has a framework for how automation earns greater authority — graduating from report-only to auto-fix as trust accumulates through demonstrated accuracy. Retirement is the complementary lifecycle direction: where the trust boundary governs promotion, retirement criteria govern decommission. Together they define the full arc of automation authority, from initial deployment through graduated promotion to eventual retirement when the problem being guarded against is structurally eliminated. Since [[maintenance scheduling frequency should match consequence speed not detection capability]], the vault already reasons about maintenance temporally — matching check frequency to problem propagation speed. Retirement extends temporal reasoning further: not just how often should this check run, but should it still be running at all? A check whose condition propagates instantly (schema violations) should fire on every write event; a check whose condition develops over months (stale descriptions) should fire monthly; and a check whose condition has been structurally eliminated should not fire at all. Since [[three concurrent maintenance loops operate at different timescales to catch different classes of problems]], retirement applies within each loop independently — a fast-loop schema check, a medium-loop orphan detector, and a slow-loop structural audit each face the same four retirement signals, evaluated against the evidence appropriate to their timescale. Retirement is the terminal tier of the scheduling spectrum — frequency zero.

This connects to a pattern from distributed systems: Wikipedia's bot governance framework blocks bots that create more cleanup work than they prevent. The principle transfers directly — an automated vault check that creates more false-alert handling work than it saves in genuine-catch work has crossed the same threshold. The vault's automation layer is itself a system that needs maintenance, and retirement is part of that maintenance. Since [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]], the safety analysis for automation focuses on whether operations are safe to repeat. But there is a complementary safety question: is an operation safe to continue indefinitely? Idempotency ensures that running a check too often is harmless. Retirement ensures that running a check after it is no longer useful does not accumulate noise that degrades the checks that are still useful.

The retirement urgency also depends on the type of automation. Since [[automated detection is always safe because it only reads state while automated remediation risks content corruption]], a redundant detection check that catches nothing wastes attention budget but causes no active harm — the worst outcome is a false alert that gets dismissed. A redundant remediation check that occasionally misfires, however, actively corrupts content while appearing to work correctly. This asymmetry means remediation automation should be evaluated for retirement more aggressively than detection automation, because the cost of keeping unnecessary remediation running is content corruption rather than mere attention waste.

The evidence for retirement decisions does not need to come from a dedicated tracking system alone. Since [[observation and tension logs function as dead-letter queues for failed automation]], the existing dead-letter infrastructure accumulates precisely the evidence that retirement criteria evaluate. A check that generates dead-letter entries flagged as false positives is producing its own retirement case. A check that generates zero entries of any kind over an extended period is producing evidence of the zero-catch signal. The dead-letter queue was designed for infrastructure repair, but it serves double duty as the empirical foundation for retirement decisions — the same observations that inform /rethink's triage also inform whether the automation that generated those observations should continue to exist.

The practical implementation requires tracking. Each automated check needs a minimal observability layer: when it last caught a genuine issue, its false positive rate over a rolling window, and whether the methodology it enforces is still current. Without this tracking, retirement decisions become subjective judgments about whether a check "feels" useful — which is exactly the kind of reasoning that since [[over-automation corrupts quality when hooks encode judgment rather than verification]] warns about encoding in infrastructure. The tracking itself should be lightweight and deterministic: increment counters, record timestamps, compare to thresholds. The retirement decision based on that tracking can then be surfaced as a recommendation for human judgment rather than automated removal, maintaining the conservative asymmetry that protects against premature retirement of a check that might still be needed. The same hygiene principle extends beyond hooks to modular architectures: since [[module deactivation must account for structural artifacts that survive the toggle]], deactivated modules leave ghost YAML fields and orphaned validation rules that persist as structural debt. Automation retirement and module deactivation share the insight that removing a capability requires explicit cleanup — the system does not clean up after itself by default, and the artifacts of abandoned automation accumulate just as the artifacts of abandoned modules do.

---
---

Relevant Notes:
- [[hooks cannot replace genuine cognitive engagement yet more automation is always tempting]] — addresses automation expansion pressure; this note adds the complementary lifecycle direction by defining when automation should contract
- [[over-automation corrupts quality when hooks encode judgment rather than verification]] — describes the creation-side failure mode; this note describes the retention-side failure mode where even correctly designed automation outlives its usefulness
- [[the determinism boundary separates hook methodology from skill methodology]] — determines what should be automated; this note determines when automated things should stop being automated
- [[confidence thresholds gate automated action between the mechanical and judgment zones]] — threshold calibration and this note's retirement signals share a dependency on empirical tracking of false positive rates as the feedback mechanism for automation governance
- [[evolution observations provide actionable signals for system adaptation]] — the diagnostic protocol this note extends: one row already identifies unused note types as over-modeling; automation retirement applies the same diagnostic logic to the automation layer itself
- [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]] — idempotency makes automation safe to run; this note asks the prior question of whether it should still be running at all
- [[maintenance scheduling frequency should match consequence speed not detection capability]] — scheduling determines how often a check runs; retirement determines whether it should run at any frequency
- [[hook-driven learning loops create self-improving methodology through observation accumulation]] — the learning loop can drive both automation creation and retirement: accumulated observations that a hook catches nothing are the signal for retirement
- [[three concurrent maintenance loops operate at different timescales to catch different classes of problems]] — the scheduling architecture where retirement operates: each of the three loops (fast, medium, slow) contains checks that may need retirement, and retirement is the terminal tier of the scheduling spectrum — frequency zero — applied per-check within any loop
- [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]] — lifecycle complement: the fix-versus-report trust boundary governs promotion from report to auto-fix; this note governs the opposite direction, decommission when an automated check no longer justifies its existence; together they define the full lifecycle of automation authority
- [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]] — the trajectory describes promotion through encoding levels; retirement is the lifecycle complement where automation moves in the opposite direction, from hook back to nothing, completing the full arc from creation through maturation to decommission
- [[observation and tension logs function as dead-letter queues for failed automation]] — dead-letter entries accumulate evidence that informs retirement decisions: a check that generates only false-positive dead-letter entries is producing the very evidence that retirement criteria evaluate
- [[automated detection is always safe because it only reads state while automated remediation risks content corruption]] — the read/write asymmetry changes retirement urgency: a redundant detection check wastes attention but causes no harm, while a redundant remediation check that occasionally misfires actively corrupts content, making remediation automation the higher-priority retirement candidate
- [[module deactivation must account for structural artifacts that survive the toggle]] — extends the retirement principle to modular architecture: just as retired hooks should be removed to prevent noise accumulation, deactivated modules leave ghost YAML fields and validation rules that persist as structural debt; retirement hygiene applies at both the automation and module levels

Topics:
- [[maintenance-patterns]]
- [[agent-cognition]]
