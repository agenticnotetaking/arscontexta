---
description: Curated module selections for common use cases (Research Vault, PKM, Project Management) give template-level simplicity as entry point while preserving underlying composability — but users who
kind: research
topics: ["[[design-dimensions]]"]
confidence: speculative
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# use-case presets dissolve the tension between composability and simplicity

Composable knowledge architectures face a persistent adoption problem. Since [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], the architecture treats each capability as an independent toggle with explicit dependencies — which is precisely what makes it powerful and precisely what makes it intimidating. A new user confronting a module catalog with dozens of independently activatable capabilities faces a decision surface that rivals the raw dimension questions that [[configuration paralysis emerges when derivation surfaces too many decisions]] describes. The composable architecture solved the engineering problem of monolithic templates but may have recreated the UX problem in different clothing: instead of "pick a template and strip what you don't need," it becomes "pick modules and hope you chose enough."

Presets propose a dissolution. A preset is a curated module selection for a common use case — "Research Vault" activates thirteen modules covering the full pipeline from capture through semantic search, "Personal Knowledge Management" activates nine modules emphasizing capture and organization, "Project Management" activates seven structure-focused modules, and "Minimal" activates only the three foundation modules. The user selects a use-case label, not a module list. The preset resolves all the dimension questions that the use case implies, and because [[configuration dimensions interact so choices in one create pressure on others]], those questions are not independent — choosing atomic granularity forces explicit linking, which demands deep navigation, which requires heavy processing. The preset author resolved these coupling constraints once: Research Vault chooses atomic granularity, explicit linking, deep navigation, heavy processing, and the corresponding modules that implement those choices. The user gets template-level simplicity — one choice produces a working system — while the underlying composability remains intact because the preset is just a named configuration of independently toggleable modules, not a monolithic artifact.

What makes this more than a template rebrand is the relationship between presets and post-activation customization. Templates are subtractive — start with everything, remove what you do not need, which requires understanding what everything does before you can judge what to remove. Presets are additive — start with what the use case requires, add modules when friction signals that something is missing. Since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], each post-preset toggle is safe by construction. Adding a module cannot corrupt existing data. Removing a module returns the system to a known valid state. This means the user can treat the preset as a starting point and modify without fear, because the architecture guarantees that any valid combination works. The progressive nature extends to validation too: since [[progressive schema validates only what active modules require not the full system schema]], a preset that activates fewer modules means fewer validation demands, so the user's daily experience matches the system's actual complexity rather than its theoretical maximum.

The connection to the seed-evolve-reseed lifecycle is direct. Since [[derived systems follow a seed-evolve-reseed lifecycle]], presets ARE the seeding mechanism — they produce the minimum viable configuration for a use case, with evolution guidelines encoding when to add complexity. A Research Vault preset user who starts writing notes and discovers they need project tracking can enable the project-management module at the moment of friction, not during initial setup when the need was hypothetical — and since [[dependency resolution through topological sort makes module composition transparent and verifiable]], the resolver explains what else needs enabling and why, turning each friction-triggered addition into architectural education. Since [[premature complexity is the most common derivation failure mode]], presets enforce the complexity budget by activating only what the use case justifies, leaving the research graph's additional insights available as evolution guidelines rather than upfront deployment. This is progressive disclosure applied to system architecture: since [[progressive disclosure means reading right not reading less]], the user absorbs complexity through use rather than comprehending it during configuration.

Presets also relate to methodology traditions as parallel naming strategies. Since [[methodology traditions are named points in a shared configuration space not competing paradigms]], traditions are community-validated dimension choices (Zettelkasten means atomic + explicit linking + deep navigation). Presets are architecturally-validated module selections (Research Vault means yaml-schema + wiki-links + atomic-notes + mocs + processing-pipeline + semantic-search + ...). Both reduce the configuration surface by naming coherent bundles. The difference is granularity: traditions name dimension choices in the abstract configuration space, presets name module selections in the concrete implementation space. A Research Vault preset could implement a Zettelkasten-derived configuration, making presets the operational implementation of tradition-informed derivation.

The claim is classified as open because the dissolution may be incomplete. Users who start with a preset and evolve through friction eventually face a system they did not design from first principles. The preset handled initial decisions, but evolution changes the module selection incrementally, and the user may reach a configuration that no longer matches any preset — a custom system without the understanding that custom composition would have built. This is a deferred onboarding cliff: the preset eliminated upfront complexity, but the user must still develop module-level understanding to evolve effectively. Whether presets truly dissolve the composability-simplicity tension or merely postpone the moment when composability's cognitive demands arrive depends on whether the evolution phase builds the understanding that upfront composition would have required. Two mechanisms work in favor of dissolution: since [[justification chains enable forward backward and evolution reasoning about configuration decisions]], a user can trace any preset-provided module back through the claims that justified it, building understanding through backward reasoning rather than forward construction, and since [[evolution observations provide actionable signals for system adaptation]], the six diagnostic patterns convert vague friction into specific structural responses, so the user learns which modules to add or reconfigure through structured signals rather than guesswork. Since [[derived systems follow a seed-evolve-reseed lifecycle]], the evolution guidelines embedded in the seed context are designed to build this understanding incrementally — each friction-triggered module addition teaches the user about that specific capability in context. But this is a hypothesis about learning through friction, not a demonstrated result. The difference between dissolving a tension and deferring it may only become visible at the reseeding phase, when the user must reason about their system's configuration as a whole rather than one module at a time.

---
---

Relevant Notes:
- [[configuration paralysis emerges when derivation surfaces too many decisions]] — the problem presets solve: paralysis arises from surfacing every dimension as a question, and presets eliminate most questions by bundling dimension choices into a use-case label
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — the architecture presets operate within: presets are named module selections, not monolithic templates, so the individual modules remain independently toggleable after the preset provides the initial configuration
- [[premature complexity is the most common derivation failure mode]] — presets calibrate the complexity budget: a well-designed preset activates only the modules justified for its use case, avoiding the structural incentive to front-load every research-justified choice
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the safety property that makes preset customization non-destructive: toggling individual modules after a preset activates or deactivates them cannot corrupt data because the guarantee covers all valid combinations
- [[derived systems follow a seed-evolve-reseed lifecycle]] — presets are the seeding mechanism: they provide minimum viable configuration for a use case, with the expectation that friction-driven evolution will customize the module selection over time
- [[methodology traditions are named points in a shared configuration space not competing paradigms]] — presets and traditions serve parallel functions as named configurations: traditions bundle dimension choices validated by community practice, presets bundle module selections validated by architectural analysis
- [[progressive schema validates only what active modules require not the full system schema]] — enables presets to start clean: a minimal preset activates few modules, so the user encounters only the validation requirements those modules declare
- [[progressive disclosure means reading right not reading less]] — the cognitive principle presets implement at the system level: users absorb system complexity progressively through use rather than comprehending it upfront during configuration
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the testing-context risk presets amplify: because presets bundle modules into convenient configurations, developers naturally test against preset combinations rather than in isolation, causing modules to silently depend on fields and conventions that other preset-bundled modules provide
- [[configuration dimensions interact so choices in one create pressure on others]] — why presets can be curated at all: dimension coupling means a use-case label implies a coherent region of the configuration space, so the preset author resolves the coupling constraints once rather than requiring each user to navigate the interaction pressures independently
- [[justification chains enable forward backward and evolution reasoning about configuration decisions]] — mitigates the deferred onboarding cliff: backward reasoning lets a user who started with a preset trace each module choice to the claims and constraints that justified it, building the understanding that upfront composition would have provided but through inspection rather than construction
- [[evolution observations provide actionable signals for system adaptation]] — the diagnostic mechanism for preset evolution: when a preset user encounters friction, the six diagnostic patterns identify whether the symptom signals a missing module, an over-modeled type, or a processing mismatch, converting vague friction into specific module-level action
- [[dependency resolution through topological sort makes module composition transparent and verifiable]] — the computational engine that makes preset activation practical: selecting a use-case label triggers topological sort on the module DAG, resolving transitive dependencies automatically and producing explanations that teach the user why modules relate
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — the post-preset evolution mechanism: presets provide curated starting points, and subsequent module additions follow friction signals rather than preset recommendations, making friction-driven adoption the evolution phase that personalizes the preset's initial configuration

Topics:
- [[design-dimensions]]
