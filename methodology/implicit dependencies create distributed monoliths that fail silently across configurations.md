---
description: When modules share undeclared coupling through conventions, environment, or co-activation assumptions, the system looks composable but cannot actually be recombined — failures surface only in
kind: research
topics: ["[[design-dimensions]]", "[[maintenance-patterns]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# implicit dependencies create distributed monoliths that fail silently across configurations

The distributed monolith is a system that has all the operational overhead of a modular architecture — separate components, defined interfaces, independent deployment — but none of the actual independence. The modules cannot be recombined freely because they are coupled through undocumented channels. In microservices, this manifests as services that technically run independently but share database schemas, deployment order assumptions, or unversioned API contracts. In composable knowledge systems, it manifests as modules that technically toggle independently but fail when activated without other modules that no dependency declaration mentions.

## How implicit dependencies form through testing context

The mechanism is straightforward. Since [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], each module declares explicit dependencies that a topological sort resolves before activation. But implicit dependencies bypass this resolution entirely. A processing-pipeline module might assume that the mocs module has already populated the `topics` field in every note's frontmatter. The dependency is never declared because the developer always tested with both modules active. In the Research preset — which enables many modules — everything works. Since [[use-case presets dissolve the tension between composability and simplicity]] by bundling modules for common use cases, the developer naturally tests against preset configurations rather than isolated modules. In the Personal preset — which enables fewer — the processing-pipeline encounters notes without `topics` and fails silently: no error, no warning, just missing output that the user discovers much later when they wonder why certain notes were never processed.

## The event bus should degrade gracefully but developers build against what they see

This is particularly insidious because since [[module communication through shared YAML fields creates loose coupling without direct dependencies]], the shared-YAML event bus is designed to make modules independent. A module that reads a field another module writes is supposed to handle the absence of that field gracefully — it's an event bus, not a function call, so the reader should treat missing fields the way an event subscriber treats events that never fire. But in practice, developers build modules against the fields they see in their test environment, and if their test environment always has the mocs module active, the `topics` field is always present. The implicit dependency forms through testing context rather than design intent, which is exactly why since [[complex systems evolve from simple working systems]], Gall's Law's incremental addition pattern paradoxically creates the conditions for phantom dependencies. Each module is added at a friction point, tested in the context of whatever else is active, and validated against that specific configuration. The module works — in that configuration. The distributed monolith grows one well-tested module at a time.

The phantom dependency variant makes this worse at scale. A module works in the full-featured preset because ten other modules happen to populate fields, create files, or establish conventions it relies on. Move it to a minimal preset and it breaks in ways that no single missing module explains, because the dependency is distributed across several implicit providers. Debugging requires reconstructing which modules were active when the target module was developed and tested — archaeology, not engineering. Since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], phantom dependencies are not just bugs but violations of the safety guarantee. The dependency resolver approves the combination because no declared dependency is missing, but the combination is effectively an invalid patch that the resolver cannot detect. The guarantee holds formally (all declared dependencies are satisfied) but fails practically (the module does not work).

## Coherence regions create structural coupling beyond accidents

The relationship to configuration coupling deepens the problem. Since [[configuration dimensions interact so choices in one create pressure on others]], modules designed for the atomic-heavy-deep coherence region naturally assume the presence of other modules from that region. A dense-linking module might assume MOC navigation exists because dense linking without MOCs produces navigational vertigo — the design dimensions couple them. This means implicit dependencies are not just accidental oversights but structural consequences of coherence regions. Modules that belong to the same coherence region form implicit clusters, and extracting one module from its cluster requires understanding the full dimension coupling that binds them.

## Declaration and isolation testing as the two-layer fix

The fix has two layers: declaration and isolation testing. At the declaration layer, every inter-module dependency must be explicit in the module's manifest — not just code dependencies (what modules must be active) but data dependencies (what YAML fields it reads, what file conventions it assumes, what processing outputs it expects). Since [[dependency resolution through topological sort makes module composition transparent and verifiable]], the resolver already audits that no module reads fields that no active module writes — but it can only audit what modules declare. Extending declarations to include data dependencies lets the resolver distinguish between "this field is always present when this module is active" and "this field might be present depending on configuration." At the isolation testing layer, every module must be tested with only its declared dependencies active, all other modules disabled. Any failure in isolation reveals an undeclared dependency. This is the composable architecture equivalent of dependency injection in software engineering: rather than letting modules reach into their environment for what they need, force them to declare everything they require and let the resolver provide it.

Since [[progressive schema validates only what active modules require not the full system schema]], progressive validation interacts with implicit dependencies in a subtle way. When the mocs module is disabled, the validator correctly stops checking for `topics`. But a processing-pipeline module that silently reads `topics` without declaring a dependency on mocs will encounter missing fields without validation ever flagging the issue. The progressive validator is doing its job — it checks what active modules require — but the implicit dependency means the processing-pipeline's actual requirements exceed its declared requirements. Progressive validation works perfectly for well-declared modules and masks problems in poorly-declared ones. The solution is to make field reads as explicit as field writes: a module that reads `topics` must declare a dependency on whatever module writes `topics`, even if that dependency is optional (the module can handle the field's absence).

The activation-direction complement to this anti-pattern is that since [[module deactivation must account for structural artifacts that survive the toggle]], composability is threatened from both directions — implicit dependencies form through undeclared reads during activation, while ghost fields persist through undeclared writes after deactivation. Together they reveal that the composable architecture's dependency graph must track both what modules consume and what they produce, not just which modules must be co-active.

## Modularity creates the possibility but discipline achieves independence

There is a deeper architectural lesson. Since [[hook composition creates emergent methodology from independent single-concern components]], the hook layer faces the same risk at smaller scale — a hook might depend on the side effects of another hook (auto-commit creating a git state that another hook reads) without declaring the relationship. But hooks are more resilient because their determinism makes interactions predictable, and their small scope limits the surface area for implicit coupling. Module-level implicit dependencies are harder to detect because modules are larger, interact through more channels, and operate across more configurations. The distributed monolith is the failure mode that composable architecture must actively prevent, not one it naturally avoids. Modularity creates the possibility of independence, but only disciplined dependency declaration achieves it.

---
---

Relevant Notes:
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — the architecture this anti-pattern undermines: composability promises independent toggleability, but implicit dependencies make modules secretly interdependent, producing a monolith that wears a modular interface
- [[module communication through shared YAML fields creates loose coupling without direct dependencies]] — the prescribed alternative: shared YAML fields as event bus replaces direct module calls, but implicit dependencies can still form through undocumented field conventions that modules assume without declaring
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the guarantee this anti-pattern violates: the guarantee holds only for modules with declared dependencies resolved by topological sort, so undeclared dependencies create valid-looking combinations that are actually invalid patches the resolver cannot detect
- [[configuration dimensions interact so choices in one create pressure on others]] — explains why implicit dependencies form naturally: dimension coupling means modules designed for one coherence region silently assume the presence of modules from that same region, making the coupling structural rather than accidental
- [[progressive schema validates only what active modules require not the full system schema]] — progressive validation can mask implicit dependencies: a module that reads a field written by another module works when both are active but fails silently when the writer is disabled, because the validator correctly does not check the field
- [[complex systems evolve from simple working systems]] — Gall's Law creates the conditions for phantom dependencies: modules added incrementally at friction points are tested in the context of whatever was already active, so undeclared dependencies on co-active modules form through testing context rather than design intent
- [[hook composition creates emergent methodology from independent single-concern components]] — structural parallel at the hook layer: hook composition also risks implicit coupling when one hook depends on side effects of another without declaring the dependency, though determinism makes hook interactions more predictable than module interactions
- [[dependency resolution through topological sort makes module composition transparent and verifiable]] — the mechanism implicit dependencies bypass: topological sort verifies all declared dependencies are satisfied and produces human-readable explanations, but it operates only on what modules explicitly declare, so undeclared field reads and convention assumptions exist in a shadow graph the resolver cannot see
- [[module deactivation must account for structural artifacts that survive the toggle]] — the reverse-direction twin: implicit dependencies form through undeclared reads of fields other modules write, while deactivation artifacts persist through undeclared writes that survive after the writing module is disabled; both violate composability through undeclared state that the dependency graph does not track
- [[use-case presets dissolve the tension between composability and simplicity]] — the primary formation vector for implicit dependencies: presets bundle modules into configurations that developers test against, so modules built for the Research preset silently depend on fields that nine other preset-bundled modules provide, and the preset's convenience amplifies the testing-context problem because the developer never needs to test modules individually
- [[each module must be describable in one sentence under 200 characters or it does too many things]] — upstream prevention: the single-sentence test constrains module scope at design time, reducing the channels through which implicit dependencies form because focused modules have smaller interaction surfaces and fewer undeclared field reads
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — the paradoxical formation mechanism: each module added at a friction point is validated only in the context of whatever is already active, so the five-repetition threshold confirms the pain is real but not that the module works in isolation from its current neighbors

Topics:
- [[design-dimensions]]
- [[maintenance-patterns]]
