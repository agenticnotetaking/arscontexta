---
description: Enabling a module creates YAML fields, MOC links, and validation rules that persist after deactivation — ghost infrastructure accumulates as structural debt unless modules define both activation and
kind: research
topics: ["[[design-dimensions]]", "[[maintenance-patterns]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# module deactivation must account for structural artifacts that survive the toggle

Composable knowledge systems celebrate the toggle. Enable a module, get its capabilities. Disable it, lose them. The promise is symmetric — addition and removal are both clean operations that leave the system in a valid state. But the reality is asymmetric in a way that matters: enabling a module creates structural commitments in the vault's content, and disabling the module does not undo those commitments. The structural artifacts survive the toggle.

Consider what happens when the processing-pipeline module is enabled. It writes `methodology` fields into note frontmatter. It adds `relevant_notes` arrays with typed relationships. It creates processing metadata that downstream modules consume. Now disable the module. The YAML fields remain in every note that was processed while the module was active. No module reads them anymore, but they persist — ghost fields that consume attention during manual inspection, appear in grep queries as false positives, and suggest to future agents that the processing-pipeline module is active when it is not. Since [[module communication through shared YAML fields creates loose coupling without direct dependencies]], the communication mechanism that makes composition elegant is exactly what makes decomposition messy. Loose coupling means no module knows about any other, which means no module knows to clean up after another's departure.

The problem extends beyond YAML fields. MOC links created by a navigation module persist after the module is disabled — notes still list `topics` references to MOCs that the navigation module would have maintained, but without the module, those MOCs stagnate while notes continue referencing them. Validation rules established by a schema module leave expectations in the template's `_schema` block that persist even after the module that justified those rules is gone. Each structural artifact type — fields, links, validation rules, processing metadata — has its own persistence pattern and its own failure mode when orphaned.

Since [[progressive schema validates only what active modules require not the full system schema]], the validation layer at least stops complaining about fields from deactivated modules. This is necessary but insufficient. Progressive schema prevents false violations, which means deactivated module fields do not create errors. But the absence of errors is not the same as the absence of debris. The fields exist, occupy space in frontmatter, appear in metadata queries, and mislead anyone who reads the YAML expecting that every field has a purpose. Progressive schema is the correct validation response, but it solves the enforcement problem while leaving the information hygiene problem untouched.

The deeper issue is that since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], the guarantee covers structural validity — no data corruption, no broken links, no module malfunction. A system with ghost fields from three deactivated modules is structurally valid. But "valid" and "clean" are different properties. The guarantee was designed for composition safety, and it succeeds at that. What it does not address is decomposition hygiene — whether the system accurately reflects its current configuration after modules have been removed. This is not a flaw in the guarantee so much as a gap in its scope. The no wrong patches principle needs a companion: no ghost patches, where deactivating a module removes the artifacts it created.

The fix has two complementary parts. First, every module must define both activation and deactivation behavior. The activation side is well-understood: since [[dependency resolution through topological sort makes module composition transparent and verifiable]], the activation sequence already declares dependencies, contributes schema fields, and registers processing steps in a computationally resolved order. The deactivation side is the mirror: specify which fields to remove (or mark as deprecated), which MOC entries to flag for review, which validation rules to retract — and resolve the cleanup order through the same dependency graph in reverse. This is the knowledge system equivalent of database migrations having both `up` and `down` methods — a composable system that only handles `up` accumulates irreversible structural debt with every experiment. Second, activation should surface the structural commitments being made. When a user enables the processing-pipeline module, the system should communicate: "This will add methodology and relevant_notes fields to all processed notes. Disabling this module later will require cleaning up these fields from N notes." Informed consent prevents surprise when the deactivation cost becomes apparent.

Since [[complex systems evolve from simple working systems]], Gall's Law encourages experimentation — add modules at friction points, see if they help, remove them if they do not. But experimentation without clean rollback is not truly experimental. If every module trial leaves permanent artifacts, the evolutionary cycle that Gall's Law prescribes accumulates debris proportional to the number of experiments attempted. The most adventurous systems — the ones that try the most modules — end up with the most ghost infrastructure. This inverts the intended dynamic: experimentation, which should lead to simplicity through selective retention, instead leads to complexity through artifact accumulation.

There is a practical tension between thoroughness and cost. Full deactivation cleanup — scanning every note for orphaned fields, removing them, verifying nothing breaks — is expensive, especially for modules that were active long enough to touch hundreds of notes. Since [[evolution observations provide actionable signals for system adaptation]], the diagnostic protocol provides structured detection: ghost fields from deactivated modules surface as the "field consistently filled with N/A" and "note type unused for 30+ days" signals, making deactivation debris diagnosable through the same observation framework that monitors system health generally. The pragmatic response is tiered cleanup: immediate retraction of validation rules and schema contributions (cheap, prevents future false compliance), deferred cleanup of content-level artifacts with a manifest of what needs attention (medium cost, enables gradual remediation), and full backfill removal only when the accumulated debris triggers reseeding. Since [[derived systems follow a seed-evolve-reseed lifecycle]], the reseeding phase is the natural point for comprehensive deactivation cleanup — when the system is being restructured anyway, removing ghost infrastructure from previous module experiments is part of the principled restructuring rather than an additional cost.

The relationship to [[tag rot applies to wiki links because titles serve as both identifier and display text]] is structural rather than obvious. Tag rot describes vocabulary drift in active infrastructure — tags that nobody searches for anymore because the vocabulary evolved. Deactivation artifacts describe abandoned infrastructure — fields that no module reads because the module was removed. Both produce noise that degrades the knowledge graph's signal-to-noise ratio, but through different mechanisms. Tag rot is gradual decay of relevance. Deactivation artifacts are sudden orphaning through configuration change. The mitigation strategies differ accordingly: tag rot requires vocabulary maintenance and synonym detection, while deactivation artifacts require lifecycle management and cleanup protocols. But both point to the same underlying truth: knowledge systems accumulate structural debt not just through growth but through the gap between what the system's state implies and what its current configuration actually uses.

---
---

Relevant Notes:
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — parent architecture that this note identifies a lifecycle gap in: the composable architecture describes activation and composition but not the reverse operation of clean decomposition
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the guarantee covers adding modules but is silent on removal: a system with ghost fields from deactivated modules is structurally valid but operationally misleading, which means the guarantee's scope needs extending to cover the full module lifecycle
- [[progressive schema validates only what active modules require not the full system schema]] — the validation-side mitigation: progressive schema stops checking fields from deactivated modules, but stopping checks is not the same as cleaning up the fields; notes still carry ghost YAML that no module reads, creating noise in manual inspection and grep queries
- [[module communication through shared YAML fields creates loose coupling without direct dependencies]] — the communication mechanism that creates the artifact problem: because modules coordinate through shared YAML rather than direct calls, deactivation leaves orphaned field values that no module consumes but that persist in every note that was touched while the module was active
- [[derived systems follow a seed-evolve-reseed lifecycle]] — reseeding is the system-level response to accumulated deactivation debris: when multiple module experiments leave enough ghost infrastructure, the system needs principled restructuring rather than incremental cleanup
- [[tag rot applies to wiki links because titles serve as both identifier and display text]] — a different kind of structural artifact decay: tag rot is vocabulary drift in active infrastructure, while deactivation artifacts are abandoned infrastructure; both produce noise that degrades the signal-to-noise ratio of the knowledge graph
- [[complex systems evolve from simple working systems]] — Gall's Law encourages experimentation by adding modules at friction points, but experimentation implies some modules will be removed; without clean deactivation, the evolutionary add-and-remove cycle accumulates debris that contradicts the simplicity Gall's Law prescribes
- [[schema evolution follows observe-then-formalize not design-then-enforce]] — the temporal complement: schema evolution adds fields when evidence justifies them, while deactivation cleanup removes fields when the module that justified them is no longer active; both follow the observe-then-act pattern
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the activation-direction twin: implicit dependencies form through undeclared reads during activation while deactivation artifacts persist through undeclared writes after removal; both reveal that the dependency graph must track what modules consume and produce, not just which modules must be co-active
- [[each module must be describable in one sentence under 200 characters or it does too many things]] — reduces deactivation cost upstream: a focused module that passes the single-sentence test writes fewer fields and creates fewer structural commitments, so its deactivation footprint is proportionally smaller and cleanup is tractable
- [[evolution observations provide actionable signals for system adaptation]] — the detection layer for deactivation debris: ghost fields from deactivated modules trigger the unused-type and N/A-field diagnostics, making the evolution observation protocol the structured mechanism for surfacing artifacts that progressive schema alone leaves unaddressed
- [[dependency resolution through topological sort makes module composition transparent and verifiable]] — handles activation order but has no reverse protocol for deactivation cleanup order: just as topological sort resolves which modules to enable and why, a reverse traversal could determine which artifacts to clean up and in what sequence when a module is removed
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — the adoption cost this note qualifies: the five-repetition threshold reduces but does not eliminate experimental additions that later get removed, so the adoption protocol should account for deactivation cost as part of the decision to enable

Topics:
- [[design-dimensions]]
- [[maintenance-patterns]]
