---
description: YAML frontmatter functions as an event bus where one module writes a field and another reads it, so modules never call each other — the file format IS the communication protocol
kind: research
topics: ["[[design-dimensions]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# module communication through shared YAML fields creates loose coupling without direct dependencies

Knowledge system modules need to coordinate, but direct dependencies between modules create the tight coupling that composability is supposed to prevent. If a processing-pipeline module calls a validation module directly, changing the validation interface breaks the pipeline. If an MOC-management module is hardcoded to fire after reflection, removing reflection breaks MOC updates. The question is how modules communicate without knowing about each other.

The answer is shared file conventions. One module writes a YAML field, another reads it, and neither knows the other exists. The processing-pipeline writes `topics: ["[[graph-structure]]"]` in a note's frontmatter. The MOC module reads that field to determine which navigation structure should include the note. The validation module reads the same field to verify topic references resolve to existing MOCs. The semantic-search module reads it to weight topic membership in retrieval scoring. Four modules, one field, zero direct dependencies between them. The file format IS the communication protocol.

This is the knowledge system equivalent of the event bus pattern in software architecture — and more precisely, since [[stigmergy coordinates agents through environmental traces without direct communication]], it is stigmergy applied to module coordination. Modules publish state changes to a shared medium (YAML frontmatter in markdown files) and other modules subscribe by reading that medium. The advantage is extreme loose coupling — since [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], adding or removing a module doesn't break the others because no module has a reference to any other module. The processing-pipeline doesn't fail if validation is disabled. The MOC module doesn't fail if semantic-search isn't running. Each module reads what it needs and ignores the rest.

The schema becomes the contract layer. Since [[schema enforcement via validation agents enables soft consistency]], the template's `_schema` block specifies which fields exist, what values are valid, and implicitly which modules are responsible for writing versus reading each field. This is Design by Contract applied to knowledge files: the note template defines preconditions (required fields), postconditions (what processing produces), and invariants (constraints that must hold throughout the note's lifecycle). When the `_schema` says `topics` is required and must be an array of wiki links, that's simultaneously documentation for humans, enforcement for validation, and a contract between the module that writes topics and every module that reads them. And since [[progressive schema validates only what active modules require not the full system schema]], the contract is scoped to the active module set — fields belonging to inactive modules are not enforced, which means the communication bus itself adapts to module activation state.

The reframing matters because it changes how you design YAML fields. If you think of `topics` as metadata about a note, you design it for the note — whatever format feels natural, whatever values seem descriptive. If you think of `topics` as a message from the processing module to the MOC module to the validation module to the search module, you design it for the communication contract — format must be parseable by consumers, values must be meaningful across module boundaries, changes must respect backward compatibility. The same field, designed from two different perspectives, produces different results. The inter-module lens produces more disciplined, more stable field definitions because every field change is understood as an interface change that affects all readers.

This connects to how [[metadata reduces entropy enabling precision over recall]], but from a different angle. That note establishes YAML frontmatter as pre-computed low-entropy representations that shrink the search space. This note shows those same fields simultaneously serve as the communication bus between system modules. The entropy reduction is a beneficial property of fields designed primarily for inter-module coordination -- when the processing module writes a well-typed `methodology` field for the benefit of downstream consumers, it incidentally creates a queryable facet that reduces retrieval entropy. The dual function is not coincidental: both uses require the same discipline (structured values, consistent formats, defined vocabularies), so designing for one achieves the other. There is actually a third function: since [[markdown plus YAML plus ripgrep implements a queryable graph database without infrastructure]], the same YAML fields that serve as inter-module communication AND entropy reduction also function as queryable node properties in a graph database where wiki links are edges and ripgrep is the query engine. The triple-duty nature of YAML fields -- communication bus, entropy reducer, and graph database properties -- is why their design discipline matters so much: each field must satisfy three different consumers simultaneously.

There is a shadow side. Event bus architectures share well-documented failure modes. Modules can't rely on write ordering — if two modules modify the same field, the last writer wins and the first writer's intent is lost. Conflicting writes must be resolved by convention (field ownership), not by the architecture itself. And since [[hook composition creates emergent methodology from independent single-concern components]], the emergent behavior that arises from multiple modules reading and writing shared fields can be as opaque as hook composition: when the MOC module produces unexpected results, diagnosing whether the problem is in the field the processing module wrote, the field the reflect module modified, or the field the validation module flagged requires understanding the full communication graph. The loose coupling that makes composition easy makes debugging hard, because the information flows through shared state rather than explicit function calls. The same tradeoff appears in microservices: event-driven architectures compose freely but produce distributed behavior that no single service's code explains. And the communication mechanism that makes composition elegant makes decomposition messy — since [[module deactivation must account for structural artifacts that survive the toggle]], disabling a module leaves orphaned field values in the shared YAML surface that no module reads anymore but that persist in every note touched during the module's active period. The most dangerous variant is that since [[implicit dependencies create distributed monoliths that fail silently across configurations]], the event bus itself becomes a vector for undeclared coupling — a module that reads a field another module writes is supposed to handle the field's absence gracefully, but developers who test with both modules active never encounter the absence, so the implicit dependency forms through testing context rather than design intent.

Because [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], this loose coupling is safe — no module can corrupt data through unexpected field interactions when each operates independently on a common surface. But the guarantee covers structural validity, not semantic coherence, which means the practical consequence for knowledge system design is a field ownership discipline. Each YAML field should have exactly one primary writer and potentially many readers. The `description` field is written by the note creator and read by search, validation, retrieval, and progressive disclosure. The `topics` field is written by the processing pipeline (or manually) and read by MOC management, validation, and navigation. When a field has multiple writers — say, both manual editing and automated enrichment can modify `relevant_notes` — the architecture needs conflict resolution conventions, not just schema definitions. This is the knowledge system equivalent of the event sourcing pattern: rather than overwriting state, append contributions and let a reconciliation pass produce the final value.

---
---

Relevant Notes:
- [[markdown plus YAML plus ripgrep implements a queryable graph database without infrastructure]] — triple duty: the same YAML fields that carry inter-module signals and reduce retrieval entropy also function as queryable node properties in the graph database; field design discipline must satisfy all three consumers
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — parent architecture: loose coupling through shared fields is the mechanism that makes independent toggleable modules compose without knowing about each other
- [[metadata reduces entropy enabling precision over recall]] — reframes the same YAML fields from an information-theoretic lens: metadata reduces retrieval entropy, while this note shows those same fields also carry inter-module signals
- [[hook composition creates emergent methodology from independent single-concern components]] — structural parallel at the automation layer: hooks compose through shared file events just as modules compose through shared YAML fields, both achieving emergent behavior from independent components that never call each other
- [[schema enforcement via validation agents enables soft consistency]] — the enforcement side of the contract: validation reads the same fields that other modules write, making schema checking itself a module that participates in the shared-field communication pattern
- [[inline links carry richer relationship data than metadata fields]] — complementary scope: YAML fields carry structured inter-module signals (type, status, topics), while inline links carry semantic relationship data that resists field encoding; both are communication channels operating at different abstraction levels
- [[stigmergy coordinates agents through environmental traces without direct communication]] — theoretical foundation: the shared-YAML event bus is stigmergy applied to module coordination; modules leave traces (YAML field writes) that other modules respond to without direct communication, making the file the coordination medium just as the nest is the coordination medium for termites
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — safety consequence: the guarantee depends on shared-state communication because modules cannot create destructive interactions through unexpected calling sequences when there are no calling sequences, only reads and writes to a common surface
- [[progressive schema validates only what active modules require not the full system schema]] — downstream consumer: progressive schema determines which shared fields get validated based on which modules are active, scoping the communication contract to match the module activation state
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the shadow side's worst case: undeclared field reads through the shared-YAML event bus form the primary vector for implicit dependencies; a module tested with both writer and reader active never encounters field absence, so the dependency forms through testing context rather than design intent
- [[module deactivation must account for structural artifacts that survive the toggle]] — the decomposition cost of loose coupling: because modules coordinate through shared YAML rather than direct calls, deactivation leaves orphaned field values that no module consumes but that persist in every note touched while the module was active

Topics:
- [[design-dimensions]]
