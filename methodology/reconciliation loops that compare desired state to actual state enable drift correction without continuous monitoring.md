---
description: The GitOps pattern of declaring desired state and periodically converging toward it replaces imperative maintenance commands with idempotent comparisons that are always safe to schedule
kind: research
topics: ["[[maintenance-patterns]]"]
methodology: ["Systems Theory", "Original"]
source: [[automated-knowledge-maintenance-research-source]]
---

# reconciliation loops that compare desired state to actual state enable drift correction without continuous monitoring

The dominant pattern for vault maintenance is event-driven: hooks fire on writes, skills fire on invocation, and the pipeline processes claims through sequential phases. But event-driven maintenance has a structural blind spot — it only catches problems that co-occur with events. Schema drift from template evolution, link rot from external renames, index staleness from batch processing, MOC drift from organic growth — these accumulate silently between events. No hook fires when a template adds a new required field and a hundred existing notes quietly become non-compliant. No event triggers when a MOC's note count creeps past the healthy threshold over weeks of gradual additions.

The reconciliation loop addresses this by inverting the maintenance model. Instead of reacting to events with imperative commands ("add this link," "fix this schema"), the system declares desired state and periodically measures divergence. The pattern comes from GitOps, where ArgoCD and Flux continuously compare the desired cluster state (declared in Git) to the actual cluster state (observed in Kubernetes) and converge toward the desired state. The same architecture applies to knowledge vault health.

For this vault, the desired state is already implicitly declared across multiple tools:

| Desired State | Detection Tool | Remediation |
|--------------|---------------|-------------|
| All wiki links resolve | `dangling-links.sh` | Fix links or create target notes |
| All notes have descriptions | `validate-schema.sh` | Add missing descriptions |
| All notes appear in topic MOCs | `moc-coverage.sh` | Add to appropriate MOC |
| qmd index matches file count | Phase 0 freshness check | Run `qmd update && qmd embed` |
| Zero orphan notes | `orphan-notes.sh` | Connect or archive |
| MOCs under threshold size | MOC health metrics | Split into sub-MOCs |

The critical property of reconciliation is that the comparison itself is idempotent — checking whether all wiki links resolve produces the same answer regardless of how many times you run it, and the check has no side effects. Since [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]], this idempotency is what makes reconciliation inherently safe to schedule. Running health checks hourly, daily, or at every session start carries zero risk because since [[automated detection is always safe because it only reads state while automated remediation risks content corruption]], the detection phase of any reconciliation loop only reads state and cannot corrupt content even when its comparisons are wrong. This safety property distinguishes reconciliation from remediation, where the actions taken to correct drift range from fully automated (run `qmd update` for a stale index) to judgment-requiring (decide whether to connect or archive an orphan). Since [[confidence thresholds gate automated action between the mechanical and judgment zones]], a mature reconciliation architecture would not treat remediation as a binary choice between auto-fix and human judgment — it would gate automated remediation by confidence, auto-applying corrections above a threshold while deferring ambiguous cases for review.

The vault already implements a lightweight reconciliation loop through the `vault-health-quick.sh` hook at session start. This compares actual state (orphan count, dangling links, MOC coverage) against desired state (zero orphans, zero danglers, full coverage) and surfaces the delta. But this is reconciliation at a single point — session start. A full reconciliation architecture would extend this to scheduled intervals and automated correction for the mechanical subset of discrepancies, because since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], the session-start check depends on sessions actually starting. Long gaps between sessions allow drift to compound undetected. Since [[maintenance scheduling frequency should match consequence speed not detection capability]], the right scheduling frequency for each reconciliation check depends on how fast the corresponding problem propagates — schema drift from template evolution develops over weeks (monthly checks suffice), while index staleness from batch processing develops within sessions (per-session checks are appropriate).

The relationship between reconciliation and event-driven maintenance is complementary, not competitive. Since [[programmable notes could enable property-triggered workflows]], event-driven triggers react immediately to state changes — a note saved with a missing field triggers validation instantly. Reconciliation catches what events miss: the field that was valid at creation time but became non-compliant when the template evolved, the link that worked yesterday but broke when its target was renamed in a different session. The hybrid approach — event-driven for immediate enforcement, scheduled reconciliation for accumulated drift — provides defense in depth without requiring either mechanism to be comprehensive alone.

Reconciliation loops also address a deeper epistemological problem. Since [[metacognitive confidence can diverge from retrieval capability]], a vault can feel healthy — sessions run smoothly, notes get created, links get added — while structural quality silently degrades. The agent's sense of system health is itself a form of metacognitive confidence that may not track actual health. Reconciliation bypasses metacognition entirely by measuring actual state against declared state, making it an anti-divergence mechanism that tests reality rather than trusting the system's self-assessment. Since [[evolution observations provide actionable signals for system adaptation]], the diagnostic protocol provides exactly the desired-state declarations that reconciliation needs: each diagnostic row specifies what healthy looks like, how to detect divergence, and what action to take. The reconciliation loop is the scheduling infrastructure that runs those diagnostics systematically rather than waiting for someone to notice symptoms.

Since [[maintenance operations are more universal than creative pipelines because structural health is domain-invariant]], the reconciliation table is itself portable — every row checks structural properties (link integrity, schema compliance, orphan status, index freshness) rather than domain semantics. A therapy journal vault, a project management vault, and a research vault would share nearly identical reconciliation tables because the desired states describe structural health that applies regardless of what content flows through the system.

The distinction between detection and remediation within the reconciliation loop maps to a deeper pattern in the vault's automation philosophy. Since [[backward maintenance asks what would be different if written today]], the mental model for note-level maintenance is intellectual reconsideration — judgment about what has changed and what should change. Reconciliation operates at the system level, and the same split applies: mechanical detection (are there dangling links? is the index stale?) requires no judgment, while meaningful remediation (should this orphan be connected or archived? should this MOC split here or there?) requires the same "what would be different" reconsideration that backward maintenance provides at the note level. Since [[the determinism boundary separates hook methodology from skill methodology]], this detection/remediation split maps precisely to the automation boundary: detection operations belong in hooks or scheduled automation because they are deterministic, while judgment-requiring remediation belongs in skills invoked by agents who can reason about context. For the remediation operations that fall between these poles, since [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]], four conjunctive conditions — deterministic outcome, reversible via git, low cost if wrong, and proven accuracy at the report level — gate whether a reconciliation remediation should self-heal or merely flag. A reconciliation check that detects a stale qmd index can self-heal because the fix passes all four conditions; a check that detects an orphaned note should only report because multiple valid responses exist and the determinism condition fails. The reconciliation loop's value is that it separates detection from remediation cleanly, ensuring that the detection side — which is always safe, always deterministic, and always valuable — runs reliably even when the remediation side must wait for judgment or pass through the four-condition gate.

---
---

Relevant Notes:
- [[backward maintenance asks what would be different if written today]] — the per-note reconsideration mental model; reconciliation loops formalize the per-system version of this question by declaring what 'correct' looks like and measuring divergence
- [[evolution observations provide actionable signals for system adaptation]] — provides the diagnostic rows that reconciliation loops operationalize: each row in the diagnostic table is a desired-state declaration paired with a detection method and a remediation action
- [[gardening cycle implements tend prune fertilize operations]] — the operations that reconciliation loops schedule: tend, prune, and fertilize are the remediation actions that execute when a reconciliation check finds divergence
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] — reconciliation and hooks solve related but distinct problems: hooks enforce quality at write time (prevention), reconciliation detects drift that accumulates between writes (detection)
- [[programmable notes could enable property-triggered workflows]] — event-driven complement: property triggers react immediately to changes while reconciliation loops catch what events miss on a schedule; the hybrid approach combines both
- [[schema validation hooks externalize inhibitory control that degrades under cognitive load]] — reconciliation loops externalize a different cognitive function: not inhibitory control (preventing bad writes) but monitoring capacity (noticing accumulated drift)
- [[metacognitive confidence can diverge from retrieval capability]] — reconciliation loops are an anti-divergence mechanism: they test actual state rather than relying on the system's sense of its own health
- [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]] — foundation: idempotency is the engineering property that makes reconciliation detection safe to schedule; compare-before-acting and upsert semantics are the specific patterns that keep remediation actions safe on retry
- [[maintenance scheduling frequency should match consequence speed not detection capability]] — provides the scheduling theory for reconciliation loops: consequence speed determines WHEN each reconciliation check should fire, and the five-tier spectrum maps directly to reconciliation frequency decisions
- [[maintenance operations are more universal than creative pipelines because structural health is domain-invariant]] — explains WHY reconciliation loops are portable across knowledge systems: every desired-state declaration in the reconciliation table checks structural properties that transfer across domains
- [[the determinism boundary separates hook methodology from skill methodology]] — the detection/remediation split within reconciliation maps to the determinism boundary: detection is deterministic and belongs in hooks or scheduled automation, remediation spans the boundary from mechanical (qmd update) to judgment-requiring (connect or archive orphan)
- [[confidence thresholds gate automated action between the mechanical and judgment zones]] — extends the remediation side: between fully automated corrections and full human judgment lies a confidence-gated zone where reconciliation remediation can act autonomously above a threshold and defer below it
- [[automated detection is always safe because it only reads state while automated remediation risks content corruption]] — foundational safety property: the detection phase of every reconciliation loop inherits the read-only safety guarantee, which is why reconciliation detection can be scheduled at any frequency while reconciliation remediation needs judgment gates
- [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]] — remediation gating criteria: provides the four conjunctive conditions that determine whether a reconciliation remediation should self-heal (all four pass) or merely report (any one fails), giving the detection/remediation split its concrete decision procedure
- [[three concurrent maintenance loops operate at different timescales to catch different classes of problems]] — scheduling container: the three-loop architecture organizes reconciliation across timescales, with each loop implementing reconciliation at its characteristic frequency — fast loops reconcile per-event, medium loops per-session, slow loops per-month — placing reconciliation as the shared pattern that each loop instantiates differently

Topics:
- [[maintenance-patterns]]
