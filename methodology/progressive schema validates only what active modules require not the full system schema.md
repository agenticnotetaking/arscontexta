---
description: Each module declares its required YAML fields and validation checks only active modules — otherwise disabling modules does not reduce schema demands, creating an all-or-nothing trap
kind: research
topics: ["[[design-dimensions]]", "[[note-design]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# progressive schema validates only what active modules require not the full system schema

A composable knowledge system fails its own premise if validation enforces the full schema regardless of which modules are active. Since [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], each module is a capability that can be enabled or disabled independently. But if the validation module checks every field that any module might need — topics for MOCs, methodology for processing pipeline, semantic neighbors for search — then disabling those modules does not actually reduce the system's demands on the user. The schema becomes a monolith wearing a composable costume: the modules are theoretically independent, but in practice you must satisfy all their requirements because the validator does not know which modules are running.

The fix is straightforward in principle: each module declares the YAML fields it requires, and the validator checks only the fields belonging to active modules. A user with only yaml-schema and wiki-links enabled should never see errors about missing `topics` or `methodology` fields, because those fields belong to the mocs module and processing-pipeline module respectively, neither of which is active. This is the knowledge system equivalent of optional types in programming — a field like `topics` is required IF the mocs module is active, optional otherwise. The schema definition needs conditional requirements: `topics: required_when(mocs)`. The generated context file includes the topics field documentation only when mocs is enabled, and the validation module checks for topics only when mocs is active.

This matters because the alternative — validating everything regardless of activation state — creates what the modular synthesis tradition would recognize as a broken patch routing. Since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], a foundation-only configuration that triggers validation errors from convention-layer fields is arguably a "wrong patch" — the module combination is valid but the validation layer rejects notes that satisfy all active requirements. Progressive schema is what extends the no wrong patches guarantee from structural integrity (no data corruption) to operational integrity (no spurious warnings). Since [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]], the module dependency graph follows the layer hierarchy: foundation modules (yaml-schema, wiki-links) have no dependencies, convention modules (atomic-notes, mocs) build on foundation, automation modules (validation, processing-pipeline) build on convention. Progressive schema respects this hierarchy by checking only the fields from the user's current active layer and below. A user at the convention layer sees convention-level requirements. A user at the foundation layer sees only the universal base: a description field and whatever their note contains. The validator does not look upward into layers the user has not reached.

The connection to enforcement style deepens the design. Since [[schema enforcement via validation agents enables soft consistency]], the vault already uses soft enforcement — warnings rather than blocks. Progressive schema adds a second axis of flexibility: not only does validation warn instead of block, it also scopes which warnings fire. Without progressive scoping, soft enforcement merely makes the pain gentler (a warning instead of an error about missing methodology), but the pain still occurs for fields the user has no reason to populate. With progressive scoping, the warning never fires in the first place because the validator knows that methodology belongs to an inactive module. The combination of soft enforcement and progressive scope creates the loosely coupled validation that composability requires.

The practical consequence is that progressive schema prevents a specific failure mode at the intersection of two sibling anti-patterns. Since [[premature complexity is the most common derivation failure mode]], deploying too much system at once overwhelms users before they develop working habits. Since [[configuration paralysis emerges when derivation surfaces too many decisions]], exposing too many choices prevents setup from completing. Non-progressive schema creates a third failure mode that operates during daily use rather than at setup or deployment: the user has successfully configured a minimal system, has started creating notes with just descriptions and wiki links, and then encounters validation warnings about topics, methodology, and relevant_notes — fields belonging to modules they deliberately chose not to enable. The response is predictable: either enable everything to silence the warnings (defeating the purpose of composable adoption), add placeholder values to satisfy the validator (the schema-stuffing anti-pattern that [[schema evolution follows observe-then-formalize not design-then-enforce]] identifies as false compliance), or abandon the system. All three responses are failures of the architecture, not the user.

The implementation pattern maps cleanly to the existing module dependency graph. Each module's declaration includes not only its code dependencies (what other modules must be active) but also its schema contributions (what YAML fields it adds to the note format). Since [[module communication through shared YAML fields creates loose coupling without direct dependencies]], the schema assembly inherits the same event-bus architecture: each module publishes its field requirements to a shared declaration surface, and the validator subscribes by collecting those declarations into a runtime schema. The validator reads the active module list, collects their schema contributions, and validates only those fields. Foundation modules contribute `description`. The wiki-links module contributes nothing additional to the schema — it operates through inline link syntax, not YAML fields. The mocs module contributes `topics`. The processing-pipeline contributes `methodology` and `relevant_notes`. The validation module itself contributes nothing — it reads what others declare. This means the schema is assembled dynamically from the active module set, and since [[schema validation hooks externalize inhibitory control that degrades under cognitive load]], the assembled schema is what the hooks enforce. The hooks fire reliably regardless of the agent's cognitive state, but what they check is scoped to what matters.

Progressive schema also interacts with implicit dependencies in a way that makes both harder to detect. Since [[implicit dependencies create distributed monoliths that fail silently across configurations]], a module that reads a field written by another module works when both are active but fails silently when the writer is disabled. The progressive validator is doing its job — it checks only what active modules require — but the implicit dependency means the reader's actual requirements exceed its declared requirements. Progressive validation works perfectly for modules with honest declarations and masks problems in modules with incomplete ones. The solution is to make field reads as explicit as field writes: a module that reads `topics` must declare a dependency on whatever module writes `topics`, even if that dependency is optional.

There is a shadow side. Progressive schema creates the risk of silent under-validation. A user who should have enabled mocs but did not will never see warnings about missing topics, which means their notes will lack the navigation metadata that mocs would have organized. The system works perfectly within its configured scope — and the user may not realize that scope is too narrow until they have hundreds of notes with no topic assignments and decide to enable mocs retroactively. The mitigation is twofold: the module recommendation engine should surface "you have 50 notes and no topics — consider enabling mocs" as proactive guidance, and the module activation process should include a backfill step that scans existing notes and flags which ones need updates for the newly activated module's schema requirements. This is incremental adoption working as designed — since [[schema evolution follows observe-then-formalize not design-then-enforce]], the evidence of 50 topic-less notes IS the observation that justifies adding the mocs module, and the backfill is the formalization step.

The deeper principle is that validation scope should match activation scope. In a monolithic system, the full schema applies everywhere because everything is always active. In a composable system, what is active varies by configuration, and validation that does not respect that variation undermines the composability it serves. Progressive schema is not a feature of validation — it is a requirement of composability. Without it, the modules are toggleable but the quality gates are not, and the quality gates are what the user actually encounters during daily work. The composability promise — start simple, add what you need, never encounter demands from features you have not adopted — requires that validation, the most frequent point of system-user interaction, honor the same principle of independent activation that the module architecture was designed around.

---
---

Relevant Notes:
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — provides the architectural context: modules are independently toggleable, so their schema requirements must be independently activatable; progressive schema is what makes module independence extend to the validation layer
- [[schema enforcement via validation agents enables soft consistency]] — the enforcement mechanism that progressive schema operates through: soft validation already warns rather than blocks, and progressive schema further scopes WHICH warnings fire based on module activation state
- [[schema evolution follows observe-then-formalize not design-then-enforce]] — complementary temporal axis: evolution governs which fields exist and when they get formalized, progressive schema governs which of those fields are checked at any given moment based on active modules; evolution is change over time, progressive schema is scope at a point in time
- [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]] — the layer hierarchy that module dependencies follow: foundation modules have no schema requirements beyond description, convention modules add topics and linking fields, automation modules add processing metadata; progressive schema checks only the fields from active layers
- [[premature complexity is the most common derivation failure mode]] — progressive schema prevents the validation equivalent of premature complexity: without it, enabling basic features forces compliance with advanced schemas, creating the same overwhelming first-encounter that premature complexity creates at the system level
- [[configuration paralysis emerges when derivation surfaces too many decisions]] — related failure mode at a different layer: configuration paralysis overwhelms during setup choices, while non-progressive schema overwhelms during daily use by demanding fields the user has not yet decided to care about
- [[schema validation hooks externalize inhibitory control that degrades under cognitive load]] — the enforcement infrastructure: hooks fire regardless of cognitive state, but progressive schema determines what those hooks check; without progressive scoping, hooks would enforce requirements from modules the user never activated
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — extends the guarantee from structural to operational: without progressive schema, valid module combinations can produce spurious validation warnings, which is arguably a wrong-patch failure at the quality-gate layer even if data integrity holds
- [[module communication through shared YAML fields creates loose coupling without direct dependencies]] — the communication substrate: progressive schema assembles its runtime validation set from the same shared-field declarations that modules use for inter-module coordination; field ownership discipline maps directly to schema contribution declarations
- [[derived systems follow a seed-evolve-reseed lifecycle]] — progressive schema enables the seed phase to start clean: minimal module activation means minimal validation requirements, so the user builds working habits before encountering convention-layer or automation-layer schema demands; each evolution step that enables a new module progressively expands validation scope
- [[multi-domain systems compose through separate templates and shared graph]] — progressive schema becomes especially important in multi-domain systems where different domains contribute different schema fields: a therapy domain's trigger and pattern_type fields should not create validation noise for research notes, and progressive scoping by domain-module activation prevents cross-domain schema interference
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the masking interaction: progressive validation correctly stops checking fields from disabled modules, but this makes undeclared field reads invisible; a module that reads topics without declaring a dependency on the mocs module works when mocs is active and fails silently when it is disabled, and the validator never flags the gap because it is checking the right things for the wrong reasons
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — ensures friction-driven adoption extends to daily experience: a user who has only added yaml-schema and wiki-links never encounters validation demands from modules they have not yet adopted, so the enforcement surface matches the adoption state

Topics:
- [[design-dimensions]]
- [[note-design]]
