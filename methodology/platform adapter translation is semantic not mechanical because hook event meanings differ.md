---
description: Each hook event carries implicit properties — timing, frequency, error handling, response format — that differ across platforms, so adapters must decompose quality guarantees and reconstruct them
kind: research
topics: ["[[agent-cognition]]"]
methodology: ["Original"]
source: [[agent-platform-capabilities-research-source]]
---

# platform adapter translation is semantic not mechanical because hook event meanings differ

When translating a knowledge system from one agent platform to another, the tempting approach is mechanical: find the equivalent event name on the target platform, wire up the same script, and move on. A PostToolUse hook that runs `validate-note.sh` on Claude Code should map to whatever event fires after tool execution on the target platform. But this mechanical mapping breaks because hook events on different platforms do not carry the same meaning, even when they seem to describe the same moment.

The subtlety emerges when you examine what "fires after a tool use" actually entails. On Claude Code, PostToolUse fires after every single tool invocation and can surface warnings back to the agent in the same conversation turn. The agent sees the validation result immediately and can correct the problem before continuing. On platforms with session-level hooks, a single event fires once at session start -- a fundamentally different timing pattern. There is no per-operation hook. To achieve the same quality guarantee ("validate notes on every write"), the adapter cannot simply rename the event. It must recognize that the guarantee itself needs a different implementation strategy, potentially falling back to instruction-based enforcement in the context file. Since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], this fallback changes the guarantee from "automatic enforcement" to "instruction-based compliance" -- a categorical downgrade, not a minor implementation detail.

This is why the translation is semantic rather than mechanical. The adapter must reason about what the hook achieves, not what event it attaches to. A schema validation hook on PostToolUse achieves: (1) fires on every write without agent memory, (2) surfaces results in real time for immediate correction, (3) operates outside the context window so it does not consume reasoning budget. Each of these properties may need a different implementation strategy on the target platform. Property (1) might require instruction repetition if no per-operation event exists. Property (2) might be achievable through a different event that happens to fire at the right moment. Property (3) might be impossible if the target platform runs all checks inside the context window.

Since [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]], this translation challenge sits precisely at the automation layer boundary. Foundation and convention layers transfer mechanically because they are files and text. But the automation layer, where hooks live, requires semantic understanding of what each platform's event infrastructure can and cannot express. The adapter pattern must therefore decompose each hook into its quality guarantee, then reconstruct that guarantee using whatever mechanisms the target platform provides -- even if the reconstruction looks nothing like the original implementation.

This decompose-and-reconstruct pattern is structurally isomorphic to what [[intermediate representation pattern enables reliable vault operations beyond regex]] describes at the document level. Pandoc decomposes documents into a canonical AST so that N input formats and M output formats require only N+M implementations rather than N*M converters. The adapter pattern decomposes hook guarantees into constituent properties so that each property can be independently reconstructed on the target platform rather than requiring a monolithic event-name mapping for every source-target pair. Both solve the same combinatorial translation problem by introducing an intermediate decomposition layer -- the difference is that Pandoc's intermediate structure is a data format (AST), while the adapter's intermediate structure is a set of quality guarantee properties (timing, scope, enforcement semantics).

The semantic translation requirement also explains why since [[blueprints that teach construction outperform downloads that provide pre-built code for platform-dependent modules]], pre-built hook files are the wrong distribution format for automation modules. A downloaded hook carries the source platform's event semantics implicitly — its timing, scope, and enforcement properties are baked into the implementation. A blueprint instead decomposes the quality guarantee into its semantic properties and teaches the agent to reconstruct them using whatever mechanisms the target platform offers. The decompose-and-reconstruct pattern this note describes at the mechanism level is precisely what blueprints formalize at the distribution level.

The practical implication for knowledge system generators is that platform detection must go beyond "does this platform have hooks?" to "what event semantics does this platform support?" Since [[platform capability tiers determine which knowledge system features can be implemented]], tiers describe rough capability classes, but within a tier, the specific event vocabulary and semantics determine what adapters can faithfully translate versus what must degrade to a lower abstraction layer. This event semantics knowledge is part of what [[self-extension requires context files to contain platform operations knowledge not just methodology]] identifies as essential: an agent that knows how to write a hook configuration file but does not understand what quality guarantee each event provides cannot perform the semantic translation that faithful adaptation requires.

---
---

Relevant Notes:
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] -- foundation: the hook-instruction gap explains WHY adapter translation must preserve enforcement semantics, not just trigger placement
- [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]] -- the automation layer is where this translation challenge lives, because hook translation IS the layer boundary between convention and automation
- [[platform capability tiers determine which knowledge system features can be implemented]] -- provides the tier framework that explains when semantic translation fails entirely: some platforms lack hook events altogether, making the adapter responsible for degradation strategy
- [[skills encode methodology so manual execution bypasses quality gates]] -- skills and hooks together form the full quality guarantee; adapter translation must preserve both the skill workflow and the hook enforcement, each requiring different translation strategies
- [[intermediate representation pattern enables reliable vault operations beyond regex]] -- structural isomorphism: Pandoc decomposes documents into a canonical AST to enable N+M translations instead of N*M converters; the adapter pattern decomposes hook guarantees into constituent properties to enable faithful cross-platform reconstruction, solving the same combinatorial translation problem at a different level
- [[platform fragmentation means identical conceptual operations require different implementations across agent environments]] -- the problem this note diagnoses at the mechanism level: fragmentation identifies the N-times implementation cost, this note explains WHY that cost cannot be eliminated through mechanical mapping
- [[self-extension requires context files to contain platform operations knowledge not just methodology]] -- extends: the platform operations content that context files must carry includes event semantics, not just syntax and file formats, because an agent that knows how to write a hook file but not what quality guarantee each event provides cannot perform semantic translation
- [[data exit velocity measures how quickly content escapes vendor lock-in]] -- exit velocity predicts this problem: automation-layer features have low exit velocity precisely because hook semantics do not transfer mechanically, making the adapter translation challenge the mechanism behind low portability scores
- [[blueprints that teach construction outperform downloads that provide pre-built code for platform-dependent modules]] — the distribution-format response: blueprints formalize the decompose-and-reconstruct pattern at the distribution level, teaching agents to rebuild quality guarantees from semantic properties rather than shipping pre-built implementations that embed source platform semantics implicitly

Topics:
- [[agent-cognition]]
