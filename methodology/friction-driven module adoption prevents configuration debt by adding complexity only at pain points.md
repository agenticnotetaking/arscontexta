---
description: Concrete thresholds — add after 5 manual repetitions, split above 500-char descriptions, remove after 3 unused sessions, cap at 15-20 active modules — operationalize Gall's Law at the module level
kind: research
topics: ["[[design-dimensions]]"]
methodology: ["Systems Theory", "Original"]
source: [[composable-knowledge-architecture-blueprint]]
---

# friction-driven module adoption prevents configuration debt by adding complexity only at pain points

The most natural way to build a composable knowledge system is to start with nothing and add modules only when their absence hurts. Since [[complex systems evolve from simple working systems]], this follows directly from Gall's Law — but where Gall's Law provides the principle ("add complexity where pain emerges"), friction-driven adoption provides the thresholds that make the principle operational. The question is not whether to add modules incrementally but when, specifically, a manual process has accumulated enough evidence to justify the overhead of a new module.

The concrete thresholds are: add a new module when the manual process it would automate has been performed five or more times. Split a module when its description exceeds 500 characters or its instructions exceed 5,000 tokens — because since [[each module must be describable in one sentence under 200 characters or it does too many things]], a module that cannot be described concisely is doing too much. Remove a module when it has gone unused for three or more sessions with no dependents. Cap active modules at fifteen to twenty, which is a context budget constraint rather than an arbitrary limit — since [[skill context budgets constrain knowledge system complexity on agent platforms]], the module count ceiling reflects the reality that every active module contributes to the context load that agents must carry.

What makes these thresholds more than engineering heuristics is that they operationalize the anti-pattern of premature orchestration. Since [[premature complexity is the most common derivation failure mode]], a well-justified claim graph can produce a system with twelve hooks and eight processing phases that collapses under its own sophistication before the user develops working habits. The five-repetition threshold prevents this by requiring demonstrated need: you cannot add a validation hook until you have manually validated five times and know from experience what the hook should check. The symptom of premature orchestration is distinctive — processing pipelines that produce false positives and validation rules that catch non-issues — because the automation was built from theory rather than observed friction.

The adoption pattern follows a specific sequence, and it dissolves the problem that [[configuration paralysis emerges when derivation surfaces too many decisions]] by removing the decision surface entirely. Start with zero modules: just markdown files with no schema, no validation, no processing pipeline. This is the kernel from which everything else grows. Where configuration paralysis asks users to choose between module options they do not yet understand, friction-driven adoption asks nothing — the user works, and pain points surface which modules to add. When the agent notices that it manually adds the same YAML fields to every note, that friction justifies enabling the yaml-schema module. When navigation becomes painful because fifty notes have no organizational structure, that friction justifies enabling the mocs module. When manual processing of inbox items follows the same steps every time, that friction justifies enabling the processing-pipeline module. Each addition resolves its own dependencies — since [[dependency resolution through topological sort makes module composition transparent and verifiable]], the system explains what else needs enabling and why — and since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], each addition is safe by construction. The user experiments with low stakes because the architecture guarantees that any valid combination works.

This pattern interacts with the broader lifecycle in a precise way. Since [[derived systems follow a seed-evolve-reseed lifecycle]], friction-driven adoption IS the evolution phase. The seed provides minimum viable modules (typically via a preset, since [[use-case presets dissolve the tension between composability and simplicity]]). The evolution phase toggles modules on at friction points using the five-repetition threshold. And when accumulated friction-driven additions drift the system into incoherence — when modules added for different pain points interact in ways that create new pain — the reseeding phase restructures the module selection using original constraints enriched by operational experience.

The diagnostic infrastructure matters because friction is only useful if it is legible. Since [[evolution observations provide actionable signals for system adaptation]], six diagnostic patterns map operational symptoms to structural causes: unused note types signal over-modeling, N/A-filled fields signal schema overreach, navigation failure signals structural misfit. These diagnostics convert vague "something feels wrong" into specific "enable this module" or "disable that one." Without structured friction detection, the five-repetition threshold degenerates into counting repetitions without understanding what they mean. And because [[justification chains enable forward backward and evolution reasoning about configuration decisions]], each friction-driven addition can trace from the specific pain point through the diagnostic protocol to the research claims that justify the module — making the adoption decision principled rather than merely reactive. And since [[schema evolution follows observe-then-formalize not design-then-enforce]], the same patience principle applies to schema fields within modules: do not formalize a field until usage evidence justifies it, even if the module is already active.

There is a shadow side to friction-driven adoption that mirrors the shadow side of composable architecture generally. Because [[implicit dependencies create distributed monoliths that fail silently across configurations]], each module added at a friction point is tested only in the context of whatever else is already active — the five-repetition threshold validates that the pain is real, but not that the module works in isolation from its current neighbors. Over time, modules accumulate undeclared dependencies on co-active modules, creating the distributed monolith that composability was designed to prevent. And since [[module deactivation must account for structural artifacts that survive the toggle]], modules added experimentally at perceived friction points and later removed leave ghost YAML fields, orphaned MOC links, and stale validation rules. The five-repetition threshold reduces but does not eliminate this: a manual process performed five times might still prove unnecessary once the broader system evolves. The adoption threshold should account not just for the benefit of adding a module but for the cost of potentially removing it — including the structural artifacts that survive the toggle. This connects to why since [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]], the encoding level should also follow friction: start with documentation of the pattern, promote to a skill when the pattern stabilizes, promote to a hook only when the pattern becomes deterministic enough that judgment is no longer required.

The deeper principle is that configuration debt — the accumulated burden of features enabled without demonstrated need — is the module-level equivalent of technical debt. Just as technical debt accrues from shortcuts that save time now but cost time later, configuration debt accrues from modules enabled "just in case" that create ongoing maintenance burden, validation noise, and context overhead. Friction-driven adoption prevents configuration debt the same way test-driven development prevents technical debt: by requiring evidence before investment. The five-repetition threshold, the 500-character description limit, the three-session removal window, and the fifteen-to-twenty module cap are not arbitrary numbers but calibrated checkpoints that keep the system's actual complexity aligned with its demonstrated needs.

---
---

Relevant Notes:
- [[complex systems evolve from simple working systems]] — provides the general principle this note operationalizes: Gall's Law says add complexity where pain emerges, this note says add a MODULE specifically after 5+ manual repetitions of the pattern it would automate
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — the architecture that makes friction-driven adoption practical: modules are independent toggles with explicit dependencies, so enabling one at a friction point resolves its own dependencies without disrupting what already works
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the safety property that makes friction-driven adoption non-destructive: each module added at a pain point cannot corrupt existing data, turning adoption decisions into low-stakes experiments rather than architectural commitments
- [[premature complexity is the most common derivation failure mode]] — the failure mode this prevents: derivation can justify 12 hooks and 8 processing phases from the claim graph, but deploying them all at once overwhelms users; friction-driven adoption is the antidote that releases justified complexity incrementally
- [[progressive schema validates only what active modules require not the full system schema]] — ensures friction-driven adoption extends to daily experience: a user who has only added yaml-schema and wiki-links never encounters validation demands from modules they have not yet adopted
- [[use-case presets dissolve the tension between composability and simplicity]] — presets provide curated starting points from which friction-driven evolution diverges: the preset handles initial module selection, and subsequent additions follow friction signals rather than preset recommendations
- [[derived systems follow a seed-evolve-reseed lifecycle]] — positions friction-driven adoption as the evolution phase mechanism: seed provides minimum viable modules, friction drives selective addition, and reseeding restructures when accumulated additions drift into incoherence
- [[evolution observations provide actionable signals for system adaptation]] — the diagnostic protocol that structures friction detection: six symptom-to-cause mappings convert vague pain into specific module-level action, making friction legible rather than intuitive
- [[module deactivation must account for structural artifacts that survive the toggle]] — the cost of friction-driven experimentation: modules added and later removed leave ghost fields and orphaned metadata, so the adoption threshold should include willingness to maintain or clean up artifacts
- [[schema evolution follows observe-then-formalize not design-then-enforce]] — parallel patience principle applied to schema fields: just as modules should be added at friction points, schema fields should be formalized when usage evidence justifies them, not when design speculation predicts them
- [[methodology development should follow the trajectory from documentation to skill to hook as understanding hardens]] — shared trajectory: methodology patterns migrate from documentation through skills to hooks as understanding accumulates, just as system capabilities migrate from manual process through convention to automated module as friction accumulates
- [[dependency resolution through topological sort makes module composition transparent and verifiable]] — ensures friction-driven additions are legible: when a user adds a module at a pain point, topological sort resolves transitive dependencies and explains what else needs enabling and why
- [[configuration paralysis emerges when derivation surfaces too many decisions]] — the adoption-level problem this dissolves: rather than surfacing all module options as upfront decisions, friction-driven adoption removes the decision surface entirely by starting with nothing and letting pain points surface which modules to add
- [[justification chains enable forward backward and evolution reasoning about configuration decisions]] — evolution reasoning makes friction-driven adoption principled: when a friction signal triggers module addition, the justification chain traces from the specific pain point to the research claims that justify the module, ensuring each addition is grounded rather than reactive
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the hidden cost: each module added at a friction point is tested only in the context of whatever else is already active, so undeclared dependencies on co-active modules form through testing context rather than design intent, paradoxically creating the distributed monolith that composability was designed to prevent

Topics:
- [[design-dimensions]]
