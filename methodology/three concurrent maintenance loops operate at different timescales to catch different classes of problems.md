---
description: Fast loops (per-event hooks) catch instant violations, medium loops (per-session checks) catch accumulated drift, and slow loops (weekly-monthly audits) catch structural evolution — each timescale
kind: research
topics: ["[[maintenance-patterns]]"]
methodology: ["Systems Theory", "Original"]
source: [[automated-knowledge-maintenance-blueprint]]
---

# three concurrent maintenance loops operate at different timescales to catch different classes of problems

A single maintenance schedule cannot serve a knowledge system because the problems it faces develop at fundamentally different rates. A schema violation exists the instant a malformed note is saved. An orphan note accumulates over the course of a session as new notes arrive without MOC updates. Stale descriptions develop over weeks as understanding evolves and the surrounding graph changes. These are not the same problem at different severities — they are different classes of problem with different propagation characteristics, and addressing them requires different operational architectures running concurrently.

The three-loop architecture groups maintenance by timescale, giving each loop a distinct character:

**The fast loop** operates per-event, typically in sub-second response. Schema validation on every write, auto-commit after every file change, index invalidation when content changes. These operations are fully mechanical — they require zero judgment and produce deterministic results. Since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], the fast loop runs as infrastructure rather than instruction, firing regardless of agent attention state. The fast loop catches problems that cannot wait because downstream operations immediately consume the output. A malformed note that passes schema validation will be linked from MOCs, cited in other notes, and indexed for semantic search — each consuming the broken state before any scheduled check could catch it.

**The medium loop** operates per-session or per-day. Health dashboards at session start, qmd freshness checks before semantic search, orphan detection between processing batches. These operations combine mechanical detection with judgment-requiring remediation. Since [[session boundary hooks implement cognitive bookends for orientation and reflection]], the medium loop's detection side is already implemented — the session-start health check compares actual vault state against desired state and surfaces the delta. The medium loop catches problems that accumulate within or across a small number of sessions but do not propagate catastrophically. Since [[agent session boundaries create natural automation checkpoints that human-operated systems lack]], the discrete session architecture provides enforcement points that continuous human operation lacks — each boundary is an event where maintenance can fire automatically, which is why the medium loop is structurally feasible for agents in a way it is not for humans. An orphan note is equally orphaned whether you detect it after one minute or one hour, so per-event checking would waste the attention budget without catching problems faster.

**The slow loop** operates per-week or per-month. Full vault health audits, meta-cognitive review of accumulated observations and tensions, trend analysis across maintenance logs, structural review of MOC sizes and graph topology. These are high-judgment operations that require loading significant context and reasoning about patterns rather than checking individual items. The slow loop catches problems that develop as understanding evolves — since [[spaced repetition scheduling could optimize vault maintenance]], individual note review at maturity-adapted intervals operates within this timescale, where newly created notes get shorter review intervals and mature notes get longer ones. Since [[evolution observations provide actionable signals for system adaptation]], the slow loop's detection side has a concrete diagnostic protocol: six observation patterns (unused types, N/A-stuffed fields, emergent fields, navigation failure, unlinked output, oversized MOCs) each mapping to specific structural causes and prescribed responses. The slow loop also catches problems that no individual check can detect: gradual methodology drift, assumption invalidation, structural imbalances in the graph.

The key insight is that each loop has a different relationship between detection and remediation. In the fast loop, detection and remediation are identical — a schema check that finds a violation blocks the write, and the agent immediately fixes it. In the medium loop, detection is mechanical but remediation requires judgment — orphan detection is a simple graph query, but deciding whether to connect or archive an orphan requires understanding the note's role. In the slow loop, even detection requires judgment — determining whether a description has gone stale requires comparing the note's claims against current understanding, which is a semantic operation. Since [[confidence thresholds gate automated action between the mechanical and judgment zones]], each loop operates at a different point on the confidence spectrum: the fast loop auto-applies, the medium loop suggests, and the slow loop logs for review. This gradient maps directly onto the question of when to fix versus merely flag — since [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]], the fast loop passes all four conditions trivially (deterministic, reversible, low-cost, trusted), the medium loop passes detection but not remediation conditions, and the slow loop fails even the determinism condition for detection itself. The four-condition framework operationalizes what it means for each loop to have a "different relationship between detection and remediation."

The loops are not nested versions of the same check but genuinely different operations. The fast loop cannot catch what the slow loop catches because stale descriptions do not violate any schema — they are valid at write time and become misleading only as context changes. The slow loop cannot replace the fast loop because a weekly audit that catches a schema violation means a week of downstream operations consumed broken state. Since [[reconciliation loops that compare desired state to actual state enable drift correction without continuous monitoring]], all three loops implement the same reconciliation pattern — declare desired state, measure divergence, correct — but they differ in what "desired state" means, how divergence is measured, and how correction happens.

This architecture also explains why since [[maintenance scheduling frequency should match consequence speed not detection capability]], the constraint on each loop's frequency is the propagation rate of the problems it targets rather than the cost of running the check. The fast loop runs per-event because schema violations propagate instantly. The medium loop runs per-session because orphan accumulation propagates at session scale. The slow loop runs per-month because description staleness propagates at the timescale of understanding evolution. Since [[automated detection is always safe because it only reads state while automated remediation risks content corruption]], running detection more frequently than necessary wastes tokens but cannot corrupt content. And since [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]], overlapping detection across loops is harmless — the fast loop and medium loop may both check for dangling links, but the redundant check produces identical results rather than compounding into errors.

The three-loop architecture relates to but differs from its sibling scheduling concepts. The consequence speed spectrum provides the theoretical principle — match frequency to propagation rate. Spaced repetition provides the note-level implementation within the slow loop — adapt review intervals to maturity. The three-loop architecture provides the organizational container — how many concurrent loops a system needs, what each loop's character should be, and how they compose without interference. Since [[gardening cycle implements tend prune fertilize operations]], the slow loop's remediation side maps to the three gardening operations: tend catches content that needs updating, prune catches notes that have overgrown, and fertilize catches connection gaps. But the detection that triggers these gardening operations happens at the medium loop's timescale (orphan detection, link density checks), while the judgment-heavy remediation happens in the slow loop's dedicated sessions. The detection and remediation for a single class of problem can span multiple loops.

The architecture also has a lifecycle dimension: checks within each loop can become obsolete. Since [[automation should be retired when its false positive rate exceeds its true positive rate or it catches zero issues]], each loop's checks need periodic evaluation — a fast-loop schema check that catches nothing for three months may indicate that upstream skills have structurally eliminated the problem, and keeping the check active wastes the attention budget the three-loop architecture was designed to protect. Retirement is the terminal tier of the scheduling spectrum: frequency zero.

When any loop's detection or remediation fails silently, since [[observation and tension logs function as dead-letter queues for failed automation]], the failure evidence accumulates in atomic observation and tension notes rather than disappearing. This matters especially for detection failures — if a medium-loop health check crashes, the system loses its self-monitoring capability without knowing it has done so, and the dead-letter queue is what makes that failure visible for the slow loop's meta-cognitive review.

Since [[maintenance operations are more universal than creative pipelines because structural health is domain-invariant]], the three-loop architecture transfers across knowledge system deployments because each loop checks structural properties (schema compliance, link integrity, graph topology) rather than domain semantics. The practical consequence for agent-operated systems is that maintenance is not a single activity scheduled at a single frequency but a concurrent architecture where multiple timescales operate simultaneously. Agent sessions are cheap — they cost tokens, not human time — but context is expensive, because it costs attention quality. Scheduling maintenance into its own dedicated sessions at the appropriate timescale preserves the quality budget of productive sessions while ensuring each class of problem gets caught at the rate its propagation demands.

---
---

Relevant Notes:
- [[maintenance scheduling frequency should match consequence speed not detection capability]] — provides the theoretical foundation: consequence speed determines detection frequency, and the three loops are the architectural embodiment of grouping problems by propagation rate into discrete operational tiers
- [[spaced repetition scheduling could optimize vault maintenance]] — operates WITHIN the slow loop: spaced repetition schedules individual note review based on maturity, but the three-loop architecture is the container that determines which timescale note-level scheduling belongs to
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] — implements the fast loop: hooks fire on every event regardless of attention state, which is why the fast loop can guarantee schema compliance while the medium and slow loops cannot guarantee anything without explicit invocation
- [[session boundary hooks implement cognitive bookends for orientation and reflection]] — implements the medium loop: session-start health dashboards surface problems that accumulated since the last session, placing the detection at exactly the right timescale for session-scale consequences
- [[reconciliation loops that compare desired state to actual state enable drift correction without continuous monitoring]] — the architectural pattern underlying all three loops: each loop is a reconciliation cycle that declares desired state and periodically measures divergence, differing only in frequency and scope
- [[automated detection is always safe because it only reads state while automated remediation risks content corruption]] — enables aggressive scheduling across all three loops: since detection only reads state, each loop can run its checks at whatever frequency consequence speed demands without risk of corruption
- [[gardening cycle implements tend prune fertilize operations]] — the slow loop's remediation actions: tend, prune, and fertilize are what happens when slow-loop detection finds structural drift, but the detection and remediation happen at different timescales within the slow loop itself
- [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]] — the safety property that makes overlapping loops harmless: when fast-loop and medium-loop checks cover the same territory, idempotency ensures redundant detection produces identical results rather than compounding errors
- [[confidence thresholds gate automated action between the mechanical and judgment zones]] — each loop has a different confidence profile: fast loops operate in the mechanical zone (schema checks are deterministic), medium loops straddle the boundary (orphan detection is mechanical but remediation requires judgment), slow loops operate primarily in the judgment zone (structural review needs semantic understanding)
- [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]] — operationalizes the detection-remediation gradient: the four conditions (determinism, reversibility, low cost, accumulated trust) explain why the fast loop auto-fixes while the slow loop only logs; the framework maps the three loops onto the fix-versus-report spectrum
- [[agent session boundaries create natural automation checkpoints that human-operated systems lack]] — explains why the medium loop is structurally feasible: discrete session boundaries provide enforcement points where health checks fire automatically, making per-session maintenance guaranteed rather than aspirational
- [[evolution observations provide actionable signals for system adaptation]] — provides the slow loop's concrete diagnostic protocol: six observation patterns mapping symptoms to structural causes give the slow loop structured detection rather than open-ended pattern recognition
- [[automation should be retired when its false positive rate exceeds its true positive rate or it catches zero issues]] — the lifecycle endpoint for checks in any loop: retirement criteria determine when a check should stop running, completing the loop lifecycle from creation through scheduling to retirement
- [[observation and tension logs function as dead-letter queues for failed automation]] — the failure capture mechanism across all three loops: when detection or remediation fails silently, the dead-letter queue makes failures visible for slow-loop meta-cognitive review rather than allowing silent degradation
- [[maintenance operations are more universal than creative pipelines because structural health is domain-invariant]] — grounds transferability: the three-loop architecture transfers across deployments because each loop checks structural properties rather than domain semantics

Topics:
- [[maintenance-patterns]]
