---
description: Topological sort on a module DAG resolves dependencies automatically while producing human-readable explanations that teach users why modules relate — turning opaque automation into education
kind: research
topics: ["[[design-dimensions]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# dependency resolution through topological sort makes module composition transparent and verifiable

When a knowledge system offers independently toggleable modules, the user faces a composition problem: enabling a module may require other modules that provide capabilities it depends on, and understanding those transitive dependencies requires tracing chains that quickly exceed what manual reasoning can track. Dependency resolution via topological sort solves the mechanical problem — given a directed acyclic graph of module dependencies, it produces a valid initialization order and identifies all transitive requirements automatically. But the more interesting contribution is that resolution can be made transparent, turning what is normally opaque automation into an explanation of why the system is structured as it is.

## The layered DAG guarantees acyclicity

The dependency graph for a composable knowledge system is a DAG aligned with the abstraction layers. Since [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]], the layer hierarchy guarantees acyclicity because dependencies always point downward — foundation modules like yaml-schema and wiki-links have no dependencies, convention modules like atomic-notes depend on foundation modules, and automation modules like processing-pipeline depend on convention modules. This layered structure means topological sort always succeeds (no cycles to detect), and the resolution order reflects the architectural logic: foundations activate first, then conventions that build on them, then automation that assumes both. The sort does not merely find AN order — it reveals THE order that the architecture implies.

## Initial versus incremental resolution

Two resolution modes serve different moments in the system's lifecycle. Initial resolution runs at setup, sorting all selected modules into a valid activation sequence — and because [[use-case presets dissolve the tension between composability and simplicity]], the most common trigger for initial resolution is a user selecting a preset, which translates a use-case label into an ordered activation sequence without exposing the module-level complexity. Incremental resolution runs when a user adds a module to an already-running system — it computes the transitive dependencies of the new module, filters those already active, and presents only what needs to be newly enabled. This incremental pattern is why dependency resolution enables Gall's Law at the module level: since [[complex systems evolve from simple working systems]], a user starts with yaml-schema and wiki-links, then adds mocs a month later when fifty notes make navigation painful. The resolver calculates that mocs requires atomic-notes, checks that atomic-notes requires yaml-schema and wiki-links (already active), and presents a single addition — atomic-notes — for confirmation. Each evolution step is minimal, legible, and safe because since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], the resolved combination cannot corrupt what already works.

## Resolution explanations as architectural education

The transparency dimension is what separates this from standard package management. Every resolution produces a human-readable explanation showing what was resolved, what was already active, and what needed to be newly enabled. When a user requests processing-pipeline, the explanation reads: "Enabling processing-pipeline also enabled atomic-notes because processing-pipeline requires structured notes with explicit linking. yaml-schema and wiki-links were already active." This transforms dependency resolution from a black box that silently enables things into an architectural tutorial that teaches users why components relate as they do. Resolution explanations are a specific instance of how [[justification chains enable forward backward and evolution reasoning about configuration decisions]] — the backward reasoning mode lets a user trace from any enabled module to the claims and constraints that required it, and the resolution explanation IS a justification chain rendered at module activation time. The user learns that processing-pipeline needs atomic-notes because pipeline phases (extract, reflect, reweave, verify) assume each note is a single claim with YAML frontmatter — not because of an arbitrary technical constraint, but because the processing methodology requires composable units to operate on.

This transparency matters because it addresses a specific failure mode of composable systems. Since [[configuration dimensions interact so choices in one create pressure on others]], module selection has design-level consequences beyond the mechanical dependencies the resolver checks. The resolver ensures all declared dependencies are satisfied, but it cannot verify that the selected modules form a coherent configuration — atomic granularity with shallow navigation is structurally valid but practically unnavigable. By explaining WHY modules depend on each other, the resolution explanation gives users the conceptual framework to evaluate coherence themselves. A user who understands that processing-pipeline needs atomic-notes because pipeline phases operate on single-claim units can reason about whether their intended workflow actually needs per-claim granularity, rather than blindly accepting whatever the resolver enables.

## Verifiability through auditable dependency contracts

The verifiability property follows from transparency. Since [[module communication through shared YAML fields creates loose coupling without direct dependencies]], what the resolver actually verifies is that the field-providing modules are active for every field that consuming modules expect to read. If mocs reads `topics` and `topics` is contributed by the atomic-notes module, the resolver ensures atomic-notes is active before enabling mocs. The dependency graph IS the communication contract: it formalizes which modules write which shared fields and which modules read them. This makes the dependency graph auditable — an architect can inspect it to verify that no module reads fields that no active module writes, that no circular dependency has crept in through an undocumented convention, and that the activation order respects the layered architecture. But since [[implicit dependencies create distributed monoliths that fail silently across configurations]], the resolver can only verify what is declared: a module that reads a field without declaring a dependency on its provider passes resolution but fails silently when the provider is absent, which means the dependency graph is trustworthy only to the extent that dependency declarations are complete. And since [[progressive schema validates only what active modules require not the full system schema]], the resolved module set determines the validation scope — what the resolver enables is exactly what the validator checks, creating consistency between the composition decision and the enforcement surface.

## Shadow sides: NP-completeness and incomplete explanations

There is a shadow side that the theoretical literature makes concrete. Dependency resolution in its general form is NP-complete — a result demonstrated through reduction from 3-SAT. For knowledge system modules the practical constraint structure is far simpler than software package repositories (tens of modules rather than millions, no version conflicts, just capability requirements), so topological sort suffices. But as a module ecosystem grows, richer constraint types may emerge — mutual exclusions between modules, version-specific capabilities, platform-conditional dependencies — that push resolution beyond what topological sort handles. The knowledge system equivalent of PubGrub-style conflict-driven solving may eventually become necessary, with its key advantage being human-readable error explanations when resolution fails. For now, the DAG structure and small module count keep resolution trivially fast, but the architecture should not assume this simplicity is permanent.

A second shadow side is that transparency can mislead when the explanation is technically correct but architecturally incomplete. Telling a user "processing-pipeline also enabled atomic-notes" explains the module dependency but not the dimension interaction — it does not explain that enabling atomic notes with a shallow navigation configuration produces friction that will eventually force enabling mocs and deep navigation too. The resolution explanation addresses module-level composition; dimension-level coherence requires additional reasoning that the resolver does not perform. The gap between what the resolver verifies (structural completeness) and what the user needs to understand (design coherence) is the same gap that [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] acknowledges — structural validity is the floor, not the ceiling. A further asymmetry emerges because [[module deactivation must account for structural artifacts that survive the toggle]]: dependency resolution handles the forward direction (what to enable when adding a module) but has no corresponding protocol for the reverse direction (what to clean up when removing a module). Resolution explanations teach users why modules were enabled; nothing teaches them what structural artifacts remain after modules are disabled.

---
---

Relevant Notes:
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — parent architecture: dependency resolution is the computational engine that makes composable module selection practical rather than manual
- [[four abstraction layers separate platform-agnostic from platform-dependent knowledge system features]] — the layer hierarchy guarantees acyclicity: dependencies always point downward through abstraction layers, so the DAG structure is a consequence of the layer design rather than an independent constraint
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — the safety property that dependency resolution preserves: resolution ensures all declared dependencies are satisfied, and the no wrong patches guarantee ensures that any resolved combination produces a valid system
- [[configuration dimensions interact so choices in one create pressure on others]] — dimension coupling is the design-level analog: dependency resolution handles module-level composition while dimension interaction handles configuration-level coherence; both constrain the valid space but at different abstraction levels
- [[complex systems evolve from simple working systems]] — incremental resolution enables Gall's Law: adding one module months later triggers resolution of only the new transitive dependencies, so the system grows at friction points without requiring upfront planning of the full dependency graph
- [[module communication through shared YAML fields creates loose coupling without direct dependencies]] — the communication substrate that dependencies point to: modules depend on shared field conventions rather than on each other directly, so what the resolver actually checks is whether the convention-providing modules are active
- [[progressive schema validates only what active modules require not the full system schema]] — extends transparency to validation: just as resolution explains what was enabled and why, progressive schema ensures only enabled modules generate validation requirements, so the user encounters consistent behavior between what resolution showed and what validation enforces
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — the anti-pattern that bypasses dependency resolution: undeclared dependencies cannot be resolved by topological sort, so the resolver approves combinations that fail silently when implicit providers are absent
- [[justification chains enable forward backward and evolution reasoning about configuration decisions]] — resolution explanations are a specific instance of justification chains: each resolution explanation is a backward-reasoning chain from enabled module to the architectural claims that require it
- [[use-case presets dissolve the tension between composability and simplicity]] — presets are the primary trigger for initial resolution: selecting a use-case label translates to a module list that the resolver sorts into activation order, giving template-level simplicity backed by composable resolution
- [[module deactivation must account for structural artifacts that survive the toggle]] — the lifecycle gap: dependency resolution handles the forward direction (what to enable) but has no corresponding protocol for the reverse direction (what to clean up when a module is removed)
- [[each module must be describable in one sentence under 200 characters or it does too many things]] — enables explanation legibility: focused modules produce dependency rationale expressible in one sentence, while unfocused modules require compound explanations that obscure the architectural teaching function resolution is designed to provide
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — the primary context for incremental resolution: when friction triggers a module addition, the resolver explains what transitive dependencies need enabling and why, turning each pain-point-driven addition into architectural education

Topics:
- [[design-dimensions]]
