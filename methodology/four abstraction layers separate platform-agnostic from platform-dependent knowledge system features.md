---
description: Foundation (files/conventions), convention (instruction-encoded standards), automation (hooks/skills/MCP), and orchestration (pipelines/teams) create a gradient from universally portable to deeply
kind: research
topics: ["[[agent-cognition]]"]
methodology: ["Original"]
source: [[agent-platform-capabilities-research-source]]
---

# four abstraction layers separate platform-agnostic from platform-dependent knowledge system features

Knowledge system features are not uniformly portable. Some work on any LLM that can read files. Others require infrastructure that only advanced agent platforms provide. The useful decomposition organizes features into four abstraction layers, each adding platform requirements that narrow the set of environments where the feature can function.

The foundation layer is completely platform-agnostic: markdown files with YAML frontmatter, wiki link conventions, atomic note patterns, MOC navigation hierarchies, and folder architecture. These are files and text conventions. Since [[local-first file formats are inherently agent-native]], this layer works because the file IS the complete artifact -- any LLM that reads files can implement a knowledge system at this layer without hooks, skills, subagents, or external tools. The foundation layer is what survives platform death. This is also why since [[data exit velocity measures how quickly content escapes vendor lock-in]], the foundation layer has maximum exit velocity -- export means copying a folder.

The convention layer adds instruction-encoded standards but still requires no infrastructure: claim-as-title naming, description quality standards, connection finding practices, quality criteria like specificity and visible reasoning, and maintenance protocols. These live in the context file as instructions the agent follows. Any platform that loads a context file can implement this layer. The conventions are powerful -- they shape note quality, enforce composability, and guide the agent's judgment -- but they depend on the agent remembering and following instructions, which since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], means compliance degrades as context fills.

The automation layer requires platform-specific infrastructure: schema validation via hooks, processing pipelines with fresh context per phase via subagent spawning, semantic search via MCP integration, session orientation via SessionStart hooks, and auto-commit via PostToolUse hooks. This is where enforcement transforms from suggestion to guarantee. Since [[the determinism boundary separates hook methodology from skill methodology]], the automation layer itself has internal structure: deterministic operations (schema validation, format checking, auto-commit) belong in hooks that fire reliably without consuming reasoning budget, while judgment operations (connection finding, description quality evaluation) belong in skills that get full cognitive attention. Since [[skills encode methodology so manual execution bypasses quality gates]], losing automation means losing not just convenience but the methodology itself -- the selectivity gates, the duplicate checking, the phase isolation that produces quality.

The orchestration layer requires the most advanced platform features: multi-phase queue processing with isolated subagents, parallel processing with team coordination, cross-phase handoff via task files, and nightly processing pipelines. This layer builds on automation but adds coordination complexity that only full-featured platforms support. Since [[operational memory and knowledge memory serve different functions in agent architecture]], the orchestration layer is where operational memory (queues, task files, handoff protocols) becomes essential -- the coordination state that bridges sessions exists at this layer because it requires the infrastructure to manage it.

The practical value of this decomposition is architectural. Since [[platform capability tiers determine which knowledge system features can be implemented]], the tiers describe what platforms CAN do while the layers describe what features NEED. Crossing them produces a capability matrix: a tier-three platform (minimal infrastructure) supports foundation and convention layers; a tier-two platform adds partial automation; a tier-one platform supports all four. A knowledge system generator can detect the platform tier and offer only features from available layers, rather than attempting graceful degradation from a full-feature assumption that was never viable. There is a third axis: since [[eight configuration dimensions parameterize the space of possible knowledge systems]], each dimension (granularity, processing intensity, automation level, etc.) describes HOW a feature varies while the layers describe WHERE it lives. The two decompositions are orthogonal — a generator navigates both the layer hierarchy and the dimension spectrums when producing a viable configuration.

The boundaries between layers are not arbitrary. Each boundary marks where a new category of platform capability becomes necessary -- and where portability narrows. The foundation-to-convention boundary requires only a context file. The convention-to-automation boundary requires event-driven hooks, which is the sharpest capability gap because since [[context files function as agent operating systems through self-referential self-extension]], it determines whether the context file's instructions can be enforced or merely suggested. The automation-to-orchestration boundary requires subagent coordination and team infrastructure. Designing with these boundaries explicit means being honest about what transfers across platforms and what does not. And since [[complex systems evolve from simple working systems]], the layers suggest a natural evolutionary sequence: start with foundation (just files), prove it works, add convention (context file instructions), observe where instruction compliance degrades, then add automation where pain emerges. Targeting all four layers at once violates Gall's Law -- even on a platform that supports all four, the system should evolve upward through the layers rather than deploying at full complexity from the start.

---
---

Relevant Notes:
- [[platform capability tiers determine which knowledge system features can be implemented]] — complementary decomposition: tiers describe platforms, layers describe features; together they form a matrix for mapping what works where
- [[local-first file formats are inherently agent-native]] — explains why the foundation layer is universally portable: plain text with embedded metadata needs no platform infrastructure at all
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] — identifies the sharpest boundary in the layer hierarchy: the jump from convention to automation is where enforcement changes from suggestion to guarantee
- [[skills encode methodology so manual execution bypasses quality gates]] — skills live in the automation layer, so platforms without skill support lose not just convenience but the encoded methodology itself
- [[context files function as agent operating systems through self-referential self-extension]] — context files span two layers: they carry convention-layer instructions and enable automation-layer self-extension, but only when the platform grants write access
- [[complex systems evolve from simple working systems]] — provides the temporal ordering: a new system should evolve through layers in sequence (foundation first, then convention, then automation) rather than targeting all four at once
- [[data exit velocity measures how quickly content escapes vendor lock-in]] — exit velocity decreases monotonically through the layers: foundation has maximum velocity, orchestration has minimum, making the layer hierarchy an exit velocity gradient
- [[schema enforcement via validation agents enables soft consistency]] — illustrates the convention-automation boundary: schema definitions live in convention (instruction-based), enforcement lives in automation (hook-based), so the same feature straddles the sharpest gap
- [[the determinism boundary separates hook methodology from skill methodology]] — provides a finer-grained decomposition within the automation layer: deterministic operations belong in hooks, judgment operations in skills
- [[knowledge system architecture is parameterized by platform capabilities not fixed by methodology]] — the design consequence: layers define what the parameters control, and parameterization adjusts implementation within each available layer
- [[platform fragmentation means identical conceptual operations require different implementations across agent environments]] — layers predict where fragmentation bites: foundation and convention are immune, automation and orchestration suffer it
- [[operational memory and knowledge memory serve different functions in agent architecture]] — the memory types map to different layers: knowledge memory (notes, MOCs) lives at foundation and convention, operational memory (queues, task files) requires automation and orchestration
- [[configuration dimensions interact so choices in one create pressure on others]] — layer dependencies are one mechanism of dimension interaction: automation-level choices cascade through processing intensity and schema density, and the layers predict which cascades are possible
- [[eight configuration dimensions parameterize the space of possible knowledge systems]] — orthogonal decomposition: layers describe WHERE features live while dimensions describe HOW features vary; a generator navigates both when producing viable configurations
- [[blueprints that teach construction outperform downloads that provide pre-built code for platform-dependent modules]] — the distribution format determined by the layer boundary: foundation and convention layers can ship as downloads (text files), but automation and orchestration layers require blueprints that teach construction because platform fragmentation makes pre-built code non-portable
- [[knowledge systems share universal operations and structural components across all methodology traditions]] — the inventory that the layers decompose by portability: the eight universal operations and nine structural components are WHAT every system has, and the four abstraction layers determine WHERE each component lives on the platform-agnostic to platform-dependent gradient

Topics:
- [[agent-cognition]]
