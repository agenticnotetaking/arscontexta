---
description: Problems that develop instantly need per-event checks while problems that develop over weeks need monthly checks — matching frequency to propagation rate prevents both wasted overhead and undetected
kind: research
topics: ["[[maintenance-patterns]]"]
methodology: ["Systems Theory", "Original"]
source: [[automated-knowledge-maintenance-blueprint]]
---

# maintenance scheduling frequency should match consequence speed not detection capability

The intuitive approach to maintenance scheduling asks: how often can we check? If a detection mechanism is cheap, run it frequently. If it is expensive, run it rarely. But this gets the question backwards. The right question is: how fast does the problem develop? A schema violation exists the instant a malformed note is written — waiting until the next session to detect it means every operation between now and then may build on the broken foundation. A stale description develops over weeks as understanding evolves — checking for it on every file write wastes attention budget on a problem that cannot yet exist.

Consequence speed — the rate at which a problem propagates or worsens after it first appears — determines the appropriate detection frequency. The principle yields a five-tier scheduling spectrum:

**Instant consequences** need per-event detection. Schema violations and broken links from bad edits create problems the moment the file is written, because downstream operations immediately consume the malformed output. This is why since [[hook enforcement guarantees quality while instruction enforcement merely suggests it]], schema validation runs as a PostToolUse hook rather than a periodic batch check. The per-event tier is the only tier where detection must be synchronous with the operation that creates the problem. Since [[schema validation hooks externalize inhibitory control that degrades under cognitive load]], the mechanism is not just frequent but externalized — the agent's own degrading attention cannot be trusted to catch instant-consequence problems, so the infrastructure catches them instead.

**Session-scale consequences** need per-session detection. Orphan notes created during a session and dangling links introduced by edits accumulate over the course of a work session but do not propagate beyond it. Since [[session boundary hooks implement cognitive bookends for orientation and reflection]], the session-start health dashboard catches problems that developed since the last session — orphan count, dangling links, MOC coverage gaps. Checking more frequently would be wasteful because the problems themselves do not worsen within a session (an orphan note is equally orphaned whether you check after one minute or one hour).

**Multi-session consequences** need weekly detection. Orphan accumulation rate and index drift develop over multiple sessions, each session potentially adding small increments of degradation. No single session creates a crisis, but unchecked accumulation over days creates structural drift. Weekly scheduled checks prevent the gradual creep from crossing into the damage zone. Since [[reconciliation loops that compare desired state to actual state enable drift correction without continuous monitoring]], the detection mechanism for this tier is periodic state comparison — declaring what healthy looks like and measuring divergence — rather than event-driven hooks or session boundary checks.

**Slow consequences** need monthly detection. Stale descriptions and content quality degradation develop as understanding evolves — a description written last month may no longer capture the note's current role in the graph. These problems cannot be detected at write time because they are not wrong when written; they become wrong as the surrounding context changes. Monthly checks match the pace at which this drift becomes actionable.

**Structural consequences** need threshold-triggered detection rather than periodic checks. Methodology drift and assumption invalidation do not follow a temporal schedule — they accumulate observation by observation until a pattern emerges. This is why the vault uses observation counts (>10) and tension counts (>5) as triggers for meta-cognitive review rather than a fixed monthly schedule. The consequence is not time-dependent but evidence-dependent.

The spectrum also has a terminal tier: frequency zero. Since [[automation should be retired when its false positive rate exceeds its true positive rate or it catches zero issues]], some checks should not run at any frequency because the condition they guard against has been structurally eliminated, their false positive rate exceeds their true positive rate, or they have been superseded by a better mechanism. Retirement is the scheduling decision that removes a check from the spectrum entirely — not just reducing its frequency to "rarely" but recognizing that the optimal frequency is never. This completes the consequence speed framework: instant, session, multi-session, slow, threshold-triggered, and retired.

The distinction from since [[spaced repetition scheduling could optimize vault maintenance]] is important: spaced repetition asks "how often should THIS note be reviewed?" based on the note's maturity and review history. Consequence speed asks "how often should THIS class of problem be checked for?" based on the problem's propagation rate. A newly created note needs frequent review (spaced repetition) AND its schema needs per-event validation (consequence speed). These are orthogonal scheduling dimensions — one targets note quality through maturity-based intervals, the other targets system health through propagation-based frequencies.

The practical implication is that since [[gardening cycle implements tend prune fertilize operations]], the three gardening operations themselves operate at different tiers. Tending (correcting based on new information) addresses problems that develop at the multi-session to monthly timescale — content becomes inaccurate as understanding changes. Pruning (splitting overgrown notes) addresses problems that develop over weeks to months — notes gradually accumulate content that should be separate. Fertilizing (creating connections) addresses problems that develop at the session to multi-session timescale — each new note creates a connection gap that widens with every subsequent note that does not reference it. Different operations, different consequence speeds, different optimal frequencies.

There is a design trap in matching detection frequency to detection cost rather than consequence speed. Cheap detection run too frequently wastes the automation budget — context tokens consumed by health dashboard output that reports no change. Expensive detection run too rarely misses problems that have already propagated. The consequence speed principle resolves the ambiguity: if the problem cannot have developed since the last check, the check is wasted regardless of how cheap it is. If the problem could have propagated catastrophically since the last check, the check is essential regardless of how expensive it is. The resolution is safe because since [[automated detection is always safe because it only reads state while automated remediation risks content corruption]], scheduling detection at any frequency carries zero risk — the worst outcome of an unnecessary check is wasted tokens, not corrupted content. And since [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]], repeated detection at the same tier cannot compound into errors. The risk asymmetry means consequence speed should govern detection frequency directly, while remediation at each tier still needs the gating that [[confidence thresholds gate automated action between the mechanical and judgment zones]] provides — determining whether the response to a detected problem should be automatic correction, a suggestion for review, or a logged observation. Consequence speed and remediation gating are complementary scheduling dimensions: consequence speed determines WHEN to detect, and since [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]], the four conjunctive conditions determine WHETHER to fix what detection finds. A fast-consequence problem detected per-event still needs to pass all four conditions before auto-fix; a slow-consequence problem detected monthly might pass all four trivially if the fix is mechanical.
---

Relevant Notes:
- [[spaced repetition scheduling could optimize vault maintenance]] — complementary scheduling dimension: spaced repetition asks how often to review THIS note based on maturity, consequence speed asks how often to check for THIS class of problem based on propagation rate
- [[hook enforcement guarantees quality while instruction enforcement merely suggests it]] — hooks implement the per-event tier of the consequence speed spectrum: schema violations propagate instantly so the detection mechanism fires on every write event
- [[schema validation hooks externalize inhibitory control that degrades under cognitive load]] — concrete instance of instant-consequence detection: schema violations are created at the moment of writing and externalized inhibitory control catches them at that moment
- [[gardening cycle implements tend prune fertilize operations]] — the three gardening operations have different consequence speeds: pruning problems (overgrown notes) develop over weeks while fertilizing gaps (missing connections) develop over days as new notes arrive
- [[session boundary hooks implement cognitive bookends for orientation and reflection]] — session start implements the per-session detection tier: health dashboard catches problems that accumulated since the last session
- [[reconciliation loops that compare desired state to actual state enable drift correction without continuous monitoring]] — implements the middle tiers: reconciliation is the architectural pattern for multi-session and slow-consequence checks, where desired state is declared and periodically compared to actual state rather than detected per-event
- [[idempotent maintenance operations are safe to automate because running them twice produces the same result as running them once]] — enables aggressive scheduling at every tier: because detection is read-only and therefore trivially idempotent, running it at whatever frequency consequence speed demands carries zero risk of corruption from repeated execution
- [[automated detection is always safe because it only reads state while automated remediation risks content corruption]] — extends the scheduling principle: the detection side of maintenance can be scheduled at whatever frequency consequence speed demands because it only reads state, while remediation at each tier needs judgment gates regardless of how fast the problem propagates
- [[confidence thresholds gate automated action between the mechanical and judgment zones]] — complements consequence speed with response calibration: consequence speed determines WHEN to check, confidence thresholds determine HOW AGGRESSIVELY to act on what the check finds, together parameterizing the full automation scheduling decision
- [[the fix-versus-report decision depends on determinism reversibility and accumulated trust]] — complementary gating dimension: consequence speed determines detection frequency, the four conjunctive conditions determine whether detected problems should be auto-fixed or merely reported; together they parameterize the complete automation scheduling question of when to check AND what to do about it
- [[automation should be retired when its false positive rate exceeds its true positive rate or it catches zero issues]] — the terminal tier of the scheduling spectrum: frequency zero; retirement is the scheduling decision that removes a check entirely rather than merely reducing its frequency
- [[three concurrent maintenance loops operate at different timescales to catch different classes of problems]] — architectural embodiment: the three-loop architecture groups problems by consequence speed into discrete operational tiers (per-event, per-session, per-month), implementing this note's scheduling principle as a concrete system design
- [[agent session boundaries create natural automation checkpoints that human-operated systems lack]] — structural enabler of the session tier: session boundaries provide the enforcement points that make per-session detection reliable rather than aspirational, connecting scheduling theory to the discrete architecture that guarantees it

Topics:
- [[maintenance-patterns]]
