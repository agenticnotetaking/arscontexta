---
description: The single-sentence test operationalizes Unix "do one thing" as a measurable constraint — if the description exceeds 200 characters, the module bundles capabilities that should be separate toggles
kind: research
topics: ["[[design-dimensions]]", "[[note-design]]"]
methodology: ["Original", "Systems Theory"]
source: [[composable-knowledge-architecture-blueprint]]
---

# each module must be describable in one sentence under 200 characters or it does too many things

The Unix philosophy says "do one thing well," but without a concrete test the principle degrades into aspiration. Developers agree their module does one thing — they just define "one thing" broadly enough to include three capabilities bundled under a unifying label. The single-sentence description test provides a measurable operationalization: if you cannot describe what a module does in one sentence under 200 characters, it does too many things and should be split.

The test works because description length is a reliable proxy for scope. A module that manages YAML schema validation is describable in a sentence: "Validates frontmatter fields against template-defined schemas." A module that manages YAML schema validation AND migration AND format conversion requires qualifiers, conjunctions, and subordinate clauses that push the description past the threshold. The length is not arbitrary — it tracks the same cognitive load that makes compound note titles unwieldy. Since [[claims must be specific enough to be wrong]], the specificity constraint on note titles and the brevity constraint on module descriptions share a mechanism: both use conciseness as evidence that the underlying concept is singular rather than bundled. A vague note title hides multiple claims; an overlong module description hides multiple capabilities.

This connects directly to how [[descriptions are retrieval filters not summaries]]. Note descriptions function as filters that help agents decide whether to load full content — brevity forces precision, and precision enables filtering. Module descriptions serve an analogous but distinct function: they help agents and human operators decide whether to enable a module, and they serve as a design-time constraint that prevents scope creep before it reaches the user. The note description is a retrieval heuristic; the module description is a design test. Both exploit the same insight — that conciseness forces clarity — but in different phases of the lifecycle.

The constraint has practical teeth beyond aesthetics. Since [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]], the composability guarantee depends on modules being independently toggleable. A module that bundles capabilities A, B, and C forces users who want only A to accept B and C as well, breaking the granular control that composability promises. The feature-creep toggle anti-pattern emerges: enabling a module implicitly enables capabilities the user did not request, and those capabilities may interact with other modules in ways the dependency graph does not capture. This is precisely how [[implicit dependencies create distributed monoliths that fail silently across configurations]] — bundled capabilities multiply the channels through which undeclared coupling forms, because each capability within the unfocused module can independently develop phantom dependencies on fields or conventions from other modules. The single-sentence test prevents this upstream: if the description cannot fit in one sentence, the module's interaction surface is too large for the dependency resolver to track. Since [[the no wrong patches guarantee ensures any valid module combination produces a valid system]], unfocused modules threaten the safety guarantee because their hidden internal interactions expand the test surface combinatorially — you must verify not just that the module composes with others, but that each of its bundled capabilities composes independently.

The description test also connects to platform constraints. Since [[skill context budgets constrain knowledge system complexity on agent platforms]], skill descriptions consume limited context space. A module whose description exceeds 200 characters because it does too many things also consumes disproportionate budget. The design principle and the platform constraint converge: even without a philosophical commitment to focused modules, the resource allocation problem of limited context space would force conciseness. But the design principle is stronger than the budget constraint — even on a platform with unlimited context, a module that cannot be described in one sentence does too many things because the problem is scope, not space.

The test also has downstream consequences for module lifecycle. Since [[module deactivation must account for structural artifacts that survive the toggle]], a focused module that writes two YAML fields and creates one MOC convention has a tractable deactivation profile — the cleanup is proportional to the scope. An unfocused module that bundles three capabilities writes six fields, touches three types of structural artifacts, and leaves ghost infrastructure distributed across multiple concerns. The single-sentence test constrains this at design time: modules that pass the test tend to have deactivation costs that users can understand and accept. Similarly, since [[dependency resolution through topological sort makes module composition transparent and verifiable]], the transparency of dependency explanations depends on modules being narrowly scoped. "Processing-pipeline requires atomic-notes because pipeline phases operate on single-claim units" is an explanation that teaches architecture. A bundled module's dependency rationale would require subordinate clauses for each capability's requirements — the explanation becomes as unfocused as the module.

There is a shadow side. The 200-character threshold is a heuristic, and heuristics have failure modes. Some genuinely singular capabilities require nuanced description because the capability itself is conceptually complex. A module for "semantic search with BM25 plus vector embeddings and LLM reranking" does one thing (search) but the implementation requires mentioning three mechanisms. The test might flag this as unfocused when it is actually focused but technically layered. The mitigation is that the test should trigger investigation, not automatic splitting. When a description exceeds the threshold, the question is: "Does this module bundle independent capabilities that users might want separately?" If yes, split. If the length comes from describing one capability with inherent complexity, the description may need tightening rather than the module needing splitting. Since [[complex systems evolve from simple working systems]], the default should favor splitting — it is easier to compose two focused modules than to manage one unfocused one — but the test is a signal, not a verdict.

The parallel to note-level design is instructive. Since [[enforcing atomicity can create paralysis when ideas resist decomposition]], atomicity is to notes what the single-sentence test is to modules — both use conciseness as evidence that the underlying concept is singular rather than bundled, and both face the same failure mode when genuinely complex singular things resist the constraint. A note that resists decomposition because the relational structure IS the insight parallels a module whose single capability requires mentioning three mechanisms. The mitigations diverge, however: note-level atomicity has no mechanical test (whether an idea "resists decomposition because it's fuzzy" versus "resists because it's genuinely relational" requires judgment), while the single-sentence test provides at least a threshold that triggers investigation. The module-level constraint is more operationalizable precisely because modules have descriptions that can be measured, while notes have claims that must be evaluated.

---
---

Relevant Notes:
- [[composable knowledge architecture builds systems from independent toggleable modules not monolithic templates]] — parent architecture: this note provides one of the design principles that makes module boundaries enforceable rather than advisory
- [[descriptions are retrieval filters not summaries]] — extends the description-as-constraint pattern from notes to modules: both use brevity as a forcing function, but notes use it for retrieval filtering while modules use it for scope enforcement
- [[claims must be specific enough to be wrong]] — shared mechanism: specificity tests work because vagueness hides bundled concerns, whether in note titles that gesture at topics or module descriptions that paper over feature creep
- [[skill context budgets constrain knowledge system complexity on agent platforms]] — platform pressure reinforces the constraint: even if the single-sentence test were not a design principle, skill description budgets would force conciseness as a resource allocation problem
- [[the no wrong patches guarantee ensures any valid module combination produces a valid system]] — depends on: focused modules with clear boundaries are what makes the combinatorial safety guarantee tractable, because unfocused modules create hidden interactions that expand the test surface
- [[complex systems evolve from simple working systems]] — enables: Gall's Law requires that each addition is understandable in isolation, and the single-sentence test ensures modules remain simple enough to evaluate independently
- [[implicit dependencies create distributed monoliths that fail silently across configurations]] — prevents upstream: unfocused modules multiply the channels through which implicit dependencies form, because bundled capabilities interact with other modules through undeclared conventions that escape the dependency resolver
- [[module deactivation must account for structural artifacts that survive the toggle]] — reduces deactivation cost: a focused module writes fewer fields and creates fewer structural commitments, so its deactivation footprint is proportionally smaller and cleanup is tractable
- [[dependency resolution through topological sort makes module composition transparent and verifiable]] — enables legibility: focused modules produce dependency explanations that teach architecture rather than obscure it, because a single-capability module's dependency rationale is expressible in one sentence
- [[enforcing atomicity can create paralysis when ideas resist decomposition]] — parallel constraint at note level: atomicity is to notes what the single-sentence test is to modules, both using conciseness as evidence of singularity, and both facing the same failure mode when genuinely complex singular things resist the constraint
- [[friction-driven module adoption prevents configuration debt by adding complexity only at pain points]] — applies the single-sentence test as a lifecycle threshold: the 500-char split trigger and 15-20 module cap are direct consequences of the describability constraint operating as a resource allocation mechanism during friction-driven evolution

Topics:
- [[design-dimensions]]
- [[note-design]]
